#### Пример 1:
Для реализации взял [задачу с литкода](https://leetcode.com/problems/roman-to-integer/description/)  

Код: [Code.java](1%2FCode.java)  
Тесты: [Tests.java](1%2FTests.java)

Сделал 6 коммитов.   
Пытался сначала написать небольшой тест и сделать фейковую реализацию, которая будет проходить этот тест.
После того, как тест проходил я делал коммит и приступал к созданию нормальной реализации.
Причём второй коммит в решении этой задачи является скорее небольшим улучшением фейковой реализации, на базе которого можно было строить нормальное решение.
После реализации я запускал тесты и если они не проходили -- откатывал все изменения, после чего начинал заново.
На четвёртом коммите, при замене фейковой реализации на нормальную, я допустил ошибку и один тест упал. 
Пришлось откатывать все изменения. Поймал себя на том, что очень не хочется это делать, ведь ошибка небольшая и можно обойтись небольшой правкой, чтобы починить тесты.
Отчасти помогло то, что количество изменений было небольшим и я смог быстро написать подобное решение, но уже с нужным исправлением.
Тесты прошли и я сделал очередной коммит. После чего добавил ещё один тест на обработку некорректных символов и набросал фейковую реализацию, которая пришла в голову (лишь бы новый тест прошёл).
Затем я это закоммитил и начал писать нормальную реализацию, здесь удалось справиться за без ошибок и я сделал очередной коммит.

В целом, изменения получилось делать довольно маленькими и не думаю, что их стоило бы делать меньше, но тут скорее дело в том,
что сама задача не очень большая, потому и изменения легко получалось делать небольшими.
Однако, если бы я работал как обычно, то, скорее всего, здесь у меня был бы всего один коммит.

#### Пример 2:

Во второй раз взял более сложную [задачу с литкода](https://leetcode.com/problems/merge-intervals/description/)

Код: [Code.java](2%2FCode.java)  
Тесты: [Tests.java](2%2FTests.java)

Вышло 9 коммитов.
Также сначала написал небольшой тест и сделал фейковую реализацию, которая проходила этот тест.
Затем создал нормальную реализацию, которая также проходила тест, это удалось сделать с первой попытки. 
Третьим коммитом я добавил ещё тестов, часть из них завершалась успешно, а для другой части пришлось добавить фейковую реализацию.
Затем я сделал мелкое улучшение, которое решило часть проблем и закоммитил его, так как тесты были зелёные, после я добавил ещё один коммит, где окончательно доработал логику под имеющиеся тесты
и избавился от фейковой реализации.
Шестой коммит добавил ещё один тест и очередную фейковую реализацию, которую я затем заменил на нормальную.
Два последних коммита посвящены упрощению полученного решения. У меня была идея как всё можно сделать, но в голове нужно было держать несколько вещей, 
поэтому восьмой коммит я сделал маленьким, избавился от кода, который точно не нужен, тесты были зелёными и я решил зафиксировать изменения, чтобы больше о них не думать.
А вот последний коммит дался тяжело, пришлось начинать заново, причём не один раз. Я пробовал реализовать немного отличные друг от друга подходы, пока не пришёл к окончательному варианту.
Опять чувствовал жалость к коду, не хотелось убирать то, что ты старался писать. Но благодаря тому, что часть изменений уже зафиксирована было проще избавиться от написанного. 
Плюс такой откат позволяет начать прорабатывать другую версию решения, проще попробовать реализовать нечто новое. А если бы я мог дорабатывать уже написанное (но ошибочное и не закомиченное),
то с большой вероятностью цеплялся бы за имеющийся подход, так как код уже написан и, кажется, что после небольшой правки всё будет работать.

### Выводы
Предложенный подход довольно интересен и может быть полезен в определённых ситуациях.  
На своей работе я выполняю коммиты не очень часто. 
Если захотеть, то можно мой типичный рабочий коммит разбить на несколько более мелких. Однако у нас так налажены процессы, что некоторые плюсы подхода из данного урока не раскрываются. 
Например, мы пишем код задачи в отдельной ветке и к другим разработчикам он попадает только перед релизом, после того как он пройдёт ревью разработчиками и получит одобрение от команды тестировщиков. 
То есть в нашем случае я могу писать код и не бояться, что ошибки, которые я допущу, доставят другим неудобства.
Однако при выполнении этого задания я ощутил ряд преимуществ предложенного подхода, который будет полезен и при наших процессах.  
Иногда, после тестирования, ты обнаруживаешь, что в одном из сценариев возникают проблемы. 
И высок соблазн написать какой-нибудь костыль, чтобы решить проблему с минимальным количеством правок. 
А если бы ты удалял плохой код, из-за которого тесты не проходят и писал бы очередное решение заново, то вполне возможно придумал бы какой-нибудь более качественный подход.
Не так жалко придумать что-то новое, ведь то, что ты уже написал, исчезло и даже старое решение придётся писать заново. Так почему бы не подумать ещё?  

Что я могу применять в своей работе:   
Я могу писать части тестов и их фейковую реализацию, могу чаще выполнять коммиты. За время выполнения задания я прочувствовал прелесть частой фиксации изменений кода. 
Ты делаешь какую-нибудь небольшую правку, коммитишь (если она проходит тесты) и можешь больше не держать её в голове. Это освобождает твоё внимание для новых доработок. 
Как будто благодаря этому процесс написания кода идёт проще и ты не так сильно напрягаешься, ибо не приходиться держать в голове много вещей сразу.
