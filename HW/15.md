### Пример 1
<details>
<summary>До</summary>

```java
public ResponseEntity<Account> create(@RequestBody Account newAccount) {
    if (newAccount.getId() != 0) {
        throw new AccountStorageException("Don't specify ID for create method");
    }
    final Account savedAccount = accountRepository.saveAndFlush(newAccount);
    final URI location = ServletUriComponentsBuilder.fromCurrentRequest().path("/{id}")
            .buildAndExpand(savedAccount.getId()).toUri();
    return ResponseEntity.created(location).body(savedAccount);
}
```
</details>

<details>
<summary>После</summary>

```java
public ResponseEntity<Account> create(@RequestBody NewAccountDto newAccountDto) {
    Account newAccount = newAccountDtoToAccountConverter.convert(newAccountDto);
    final Account savedAccount = accountRepository.saveAndFlush(newAccount);
    final URI location = ServletUriComponentsBuilder.fromCurrentRequest().path("/{id}")
            .buildAndExpand(savedAccount.getId()).toUri();
    return ResponseEntity.created(location).body(savedAccount);
}
```
</details>

Есть метод создания учётной записи, который на вход принимает объект типа Account(является моделью БД).  
В методе создания нового аккаунта ID должен быть пустым. В старом коде выполняется проверка, что пользователь не передавал ID.
В новой версии изменён тип входного параметра. В нём не используется ID. А после получения этот объект конвертируется в объект типа Account.  
Благодаря этому нет нужды проверять наличие заданного поля ID.

### Пример 2
<details>
<summary>До</summary>

```java
    public ResponseEntity<?> moveAccountProperties(
            @ApiParam("аккаунт, на который переносятся данные.")
            @RequestParam(value = "san", required = false) String san,
            @ApiParam("аккаунт, с которого переносим данные.")
            @RequestParam(value = "sourceSan", required = false) String sourceSan) {

        if (Strings.isNullOrEmpty(san) || Strings.isNullOrEmpty(sourceSan)) {
            throw new AuthStorageException("You have to specify 'san' and 'sourceSan' params");
        }

        accountService.moveAccountProperties(san, sourceSan);

        return ResponseEntity.ok().build();
    }
```
</details>

<details>
<summary>После</summary>

```java
     public ResponseEntity<?> moveAccountProperties(
        @ApiParam("аккаунт, на который переносятся данные.")
        @RequestParam(value = "san") String san,
        @ApiParam("аккаунт, с которого переносим данные.")
        @RequestParam(value = "sourceSan") String sourceSan) {

        accountService.moveAccountProperties(san, sourceSan);

        return ResponseEntity.ok().build();
    }
```
</details>

Есть метод переноса данных с одной учётной записи на другую. Для его работы должны быть указаны номера исходной и целевой учёток.
В изначальном варианте в коде контроллера параметры были помечены как необязательные и при получении вручную проверялись на null/пустоту.
Сделал параметры обязательными, убрал проверки на null/пустоту, теперь этим занимается Spring.  
Неоднозначный момент: теперь в сервис может попасть пустая строка (но не null). Там выполняется поиск учёток в БД и если ничего не обнаружится, то будет проброшена ошибка.
С одной стороны мы избавились от блока if, но с другой -- в некоторых случаях получили до двух лишних похода в БД.   
Кажется, что в рамках задания такое решение выглядит нормально, да и наверное в большинстве случаев тоже, но наверное могут быть ситуации, когда лучше оставить изначальный вариант. 

### Пример 3
<details>
<summary>До</summary>

```java
...
//контроллер
    public ResponseEntity<CredentialViewDto> create(
            @RequestBody @Validated CredentialCreationDto requestBody) {
        final CredentialViewDto savedCredential = credentialService.create(requestBody);
        final URI location = ServletUriComponentsBuilder.fromCurrentRequest().path("/{id}")
                .buildAndExpand(savedCredential.getId()).toUri();
        return ResponseEntity.created(location).body(savedCredential);
    }
...
//сервис
    public CredentialViewDto create(CredentialCreationDto form) {
        Objects.requireNonNull(form);
        Objects.requireNonNull(form.getLogin());
        Objects.requireNonNull(form.getType());
        
        //логика
    }
```
</details>

<details>
<summary>После</summary>

```java
...
//контроллер
public ResponseEntity<CredentialViewDto> create(
        @RequestBody @Validated CredentialCreationDto requestBody) {
    final CredentialViewDto savedCredential = credentialService.create(requestBody);
    final URI location = ServletUriComponentsBuilder.fromCurrentRequest().path("/{id}")
            .buildAndExpand(savedCredential.getId()).toUri();
    return ResponseEntity.created(location).body(savedCredential);
}
...
//сервис
public CredentialViewDto create(CredentialCreationDto form) {
    //логика
}
```
</details>

Есть метод для создания кредов. Он принимает параметры в теле запроса. В контроллере используется DTO, в котором над полями проставлены аннотации для валидации (поле не пустое и т.д.), 
также этот дто помечен аннотацией `@Validated`, благодаря которой проводятся соответствующие проверки. 
Однако в сервисе есть три вызова, которые проверяют, что уже провалидированные поля не null. В данном случае вызов этих методов выглядит избыточным, так как подобные проверки были выполнены раньше.
В новой версии эти избыточные вызовы были убраны из сервиса.

### Пример 4
<details>
<summary>До</summary>

```java
public void validate(AsyncOrderCallbackParams params) {
    validationUtils.validateInSet(params.getStatus(), "status", "DONE", "ERROR");
//прочая логика валидации
}

public void asyncOrderCallback(@Valid AsyncOrderCallbackParams params) {
    asyncOrderCallbackParamsValidator.validate(params);
    AsyncOrderCallbackParamsServiceParams serviceParams =
            sdpConversionService.convert(params, AsyncOrderCallbackParamsServiceParams.class);
    bonusProgramService.subscribeServiceByBonusProgramCallback(serviceParams);
}

public class AsyncOrderCallbackParams {
    ...
    @CommandParameter(required = true)
    private String status;
    ...
}
```
</details>

<details>
<summary>После</summary>

```java
public void validate(AsyncOrderCallbackParams params) {
    //прочая логика валидации
}

public void asyncOrderCallback(@Valid AsyncOrderCallbackParams params) {
    asyncOrderCallbackParamsValidator.validate(params);
    AsyncOrderCallbackParamsServiceParams serviceParams =
            sdpConversionService.convert(params, AsyncOrderCallbackParamsServiceParams.class);
    bonusProgramService.subscribeServiceByBonusProgramCallback(serviceParams);
}

public class AsyncOrderCallbackParams {
    ...
    @CommandParameter(required = true)
    private OrderStatus status;
    ...
}
```
</details>

Есть метод принимающий результат выполнения заявки на подключение услуги в бонусной системе. Одним из полей ответа является статус подключения.
Раньше статус задавался строкой и в валидаторе проверяли, что значение строки принадлежит множеству допустимых значений.
Теперь статус задаётся перечислением и нет нужды выполнять проверку на принадлежность множеству. Spring сам пробросит ошибку, в случае передачи некорректного статуса.

### Пример 5
<details>
<summary>До</summary>

```java
...
<div class="mb-2">
    <label for="status" class="form-label">Статус</label>
    <input type="text" id="status" name="status" class="form-control form-control-sm" th:value="*{status}">
</div>
...
```
</details>

<details>
<summary>После</summary>

```java
<div class="mb-2">
    <label for="status" class="form-label">Статус</label>
    <select name="status">
        <option th:each="status : ${statuses}"
                th:value="${status}"
                th:text="${status}">
        </option>
    </select>
</div>
```
</details>

На фронтенде есть форма с фильтрами, одним из полей является статус (на бэке представлен перечислением). 
В этой форме значение статуса вводится руками, что может привести к ошибкам, на бэке выполняется проверка, что статус имеет допустимое значение.
В новом варианте кода, поле ввода статуса заменено на выпадающий список со всеми возможными значениями, что исключает ситуацию, когда пользователь вводит некорректный статус.

### Выводы 
Почему защитное программирование не самая лучшая штука? Кажется, что применение такого подхода позволяет разработчику меньше думать над дизайном кода. 
Гораздо проще воткнуть проверку в том или ином месте, чем думать над тем как бы изменить дизайн кода так, чтобы та или иная ошибка была невозможна.
Из-за чего размеры кодовой базы увеличиваются, код может становиться сложнее для понимания.  
Однако у меня не повернётся язык говорить, что защитные проверки вообще не нужны. Всё же следует проверять то, что передают нам пользователи или сторонние системы. 
Но эти проверки должны быть обоснованы дизайном системы.  

Уже не первый раз во время выполнения заданий этого формата я убеждаюсь, что примитивные типы данных -- не очень хорошо. И лучше использовать специализированную систему типов, если мы хотим получить более надёжную программу, которая будет проще для восприятия и менее подвержена ошибкам.
И опять можно прийти к выводу, что очень важно продумывать дизайн системы заранее, чтобы он даже не допускал возникновения целых классов ошибок. Это повысит не только надёжность системы, но и может вполне упростить её понимание, так как код будет отображать логику системы, и не будет перегружен лишней мишурой.