### Призрачное состояние
#### Пример 1
```java
private int compareServices(ServiceDto a, ServiceDto b) {
    //1. Сначала выводим активные услуги
    int priorityA = getActivityPriority(a);
    int priorityB = getActivityPriority(b);

    if (priorityA != priorityB) {
        return Integer.compare(priorityA, priorityB);
    }

    //2. Опциональные услуги
    if (a.isOptional() ^ b.isOptional()) {
        return Boolean.compare(b.isOptional(), a.isOptional());
    }

    //Родительские записи должны идти раньше дочерних.
    if (a.isChild() && !b.isChild()) {
        return 1;
    }
    if (!a.isChild() && b.isChild()) {
        return -1;
    }

    //3. Учитываем приоритет дискриминатора
    int discrPriorityA = getDiscriminatorPriority(a.getDiscriminator());
    int discrPriorityB = getDiscriminatorPriority(b.getDiscriminator());
    if (discrPriorityA != discrPriorityB) {
        return Integer.compare(discrPriorityA, discrPriorityB);
    }

    //4. Лексикографический порядок дискриминатора
    int discrCompare = Comparator.nullsLast(String::compareTo)
            .compare(a.getDiscriminator(), b.getDiscriminator());

    if (discrCompare != 0) {
        return discrCompare;
    }

    //5. Лексикографический порядок названия услуги
    return a.getName().compareTo(b.getName());
}
```
Есть метод, который используется в качестве компаратора для сортировки услуг. В методе содержится несколько переменных, которые хранят промежуточные состояния(`priorityA`, `discrCompare`, `discrPriorityA`...). Сам метод выглядит довольно жутко и разобраться в нём сложно.
В итоге метод был переписан на более понятный и компактный вариант. 

```java
Comparator<ServiceDto> comparator = Comparator.comparing((ServiceDto s) -> !isActive(s))
                .thenComparing(s -> !s.isOptional())
                .thenComparing(ServiceDto::isChild)
                .thenComparingInt(s -> getDiscriminatorPriority(s.getDiscriminator()))
                .thenComparing(Comparator.nullsLast(Comparator.comparing(ServiceDto::getDiscriminator)))
                .thenComparing(ServiceDto::getName);
```

#### Пример 2
```java
public static int getTonerCosts(String Line)
{
    char[] printedСharacters = Line.toCharArray();
    int tonerCostsTotal = 0;

    for (int i = 0; i < printedСharacters.length; i++) {
        if (symbolsCost.containsKey(printedСharacters[i])) {
            tonerCostsTotal += symbolsCost.get(printedСharacters[i]);
        } else {
            tonerCostsTotal += 23;
        }
    }
    return tonerCostsTotal;
}
```
Откопал код своих первых решений 28 задач :). Думаю, что `printedСharacters` можно отнести к призрачной переменной. Избыточная, особо ничем не помогает, в спецификации не определена. 
При этом код становится сложнее для понимания, так как добавляется сущность, о которой нужно думать. Наверное к избыточной переменной можно отнести и счётчик цикла, ибо здесь в нём нет нужды. Хотя и не хочется говорить, что он сильно повышает хрупкость кода.  
Код метода можно переписать так, как показано ниже. Избавились от лишних переменных, всё стало компактнее и понятнее.

```java
...
public static int getTonerCosts(String Line)
{
    int tonerCostsTotal = 0;

    for (char character : Line.toCharArray()) {
        tonerCostsTotal += symbolsCost.getOrDefault(character, DEFAULT_COST);
    }

    return tonerCostsTotal;
}
```

### Погрешность/Неточность
#### Пример 1
```java
public PageResult<Vehicle> findByEnterprises(Collection<Enterprise> enterprises, int page, int size) {
     List<Vehicle> vehicles = vehicleRepository.findByEnterprises(enterprises, page, size);
     long vehicleCount = vehicleRepository.countVehiclesByEnterprises(enterprises);

     return PageResult.<Vehicle>builder()
             .page(page)
             .size(size)
             .totalPages(Math.ceilDiv(vehicleCount, size))
             .totalElements(vehicleCount)
             .content(vehicles)
             .build();
}
```

Есть метод, который достаёт из БД список автомобилей указанных предприятий, в этом методе используется неявная сортировка по id автомобиля.
Изначально в методе требовалось организовать постраничный вывод с упорядочиванием по какому-нибудь полю. Для этой цели было выбрано поле, содержащее id автомобиля.
Логику можно расширить, добавив возможность влиять на сортировку результата.
В обновлённой версии появилась возможность указать произвольное поле и порядок для сортировки.

```java
/*
  Возвращает список автомобилей указанных предприятий в режиме пагинации.
  Есть возможность указать поле по которому будет происходить сортировка результатов, порядок сортировки(ASC/DESC), количество элементов на странице и номер страницы.
*/
public PageResult<Vehicle> findByEnterprises(Collection<Enterprise> enterprises, int page, int size, String sortField, SortOrder sortOrder) {
    List<Vehicle> vehicles = vehicleRepository.findByEnterprises(enterprises, page, size, sortField, sortOrder);
    long vehicleCount = vehicleRepository.countVehiclesByEnterprises(enterprises);

    return PageResult.<Vehicle>builder()
            .page(page)
            .size(size)
            .totalPages(Math.ceilDiv(vehicleCount, size))
            .totalElements(vehicleCount)
            .content(vehicles)
            .build();
}
```
#### Пример 2
```java
public void updatePrograms() {
        scheduleRepository.findByStatus(Status.PENDING).forEach(this::updateDbPrograms);
    }
```

Есть метод обновления программы передач, который достаёт все заголовки из БД(заголовки содержат информацию о программе передач на неделю),
в статусе PENDING и для каждого из них вызывает команду на обновление программы передач в БД(подгрузить новое расписание, возможно сравнить со старым и сохранить обновлённые записи в БД).
В REST API есть метод, который вызывает этот updatePrograms. Проблема текущей реализации том, что в ней считается будто нам нужно обновлять заголовки лишь в статусе PENDING, однако у нас есть ещё статус FAILED(загрузка программы передач не удалась по какой-либо причине). 
Заголовки в таком статусе тоже было бы полезно обновить в ряде случаев.
В новой версии метода статус заголовков для обновления программы передач задаётся параметром, что расширяет варианты его использования. 

```java
/*
  Метод обновляет программу передач для заголовков расписаний в указанном статусе.
 */
public void updateProgramsForSchedules(Status status) {
        scheduleRepository.findByStatus(status).forEach(this::updateDbPrograms);
    }
```
#### Пример 3
```java
public Image getOrCreateImage(String url, EventType eventType) {
    return imageRepository.findByUrl(url)
            .orElseGet(() -> imageRepository.save(Image.builder()
                    .name(IMG_PREFIX + eventType.getID() + ".jpg")
                    .url(url)
                    .build()));
}
```

Есть метод, который возвращает информацию об изображении из БД, если такой нет, то он её создаст, а затем вернёт.
Поиск в БД выполняется по url изображения. Этот же url содержит в себе имя файла с расширением. Изначальный код построен с предположением о том, что картинка всегда будет иметь формат `.jpg`.
Однако, на самом деле, никто не видел таких гарантий, что нам всегда будут поступать `.jpg`. Кажется, что это является неточностью, код следует расширить и заложиться на то, что к нам могут приходить изображения разных форматов.
В обновлённой версии метода расширение получаемого изображения не хардкодится, как `.jpg`, а вычисляется на основе ссылки(ссылки имеют одинаковый вид и содержат имя файла).
Вообще хорошо бы разбить его функционал на две части, а то сейчас всё очень похоже на нарушение SRP, но поскольку это занятие о другом, то пока оставлю его в таком виде. 

```java
/*
  Метод возвращает из БД информацию об изображении по переданному url, если её там не оказалось, то сначала информация будет сохранена в БД.
  Сохраняется имя изображения и ссылка на его загрузку. Имя состоит из специального префикса, идентификатора события, к которому относится изображение, а также типа файла.
  Тип файла изображения не зафиксирован, но всегда указан в ссылке на загрузку этого изображения в параметре filename.
  Информация об изображении содержит ...
 */
public Image getOrCreateImage(String url, EventType eventType) {
    String imageExtension = getImageExtension(url);
    return imageRepository.findByUrl(url)
            .orElseGet(() -> imageRepository.save(Image.builder()
                    .name(IMG_PREFIX + eventType.getID() + imageExtension)
                    .url(url)
                    .build()));
}
```

### Когда интерфейс явно не должен быть проще реализации
- Криптография. Довольно важная область, где ошибки могут стоить дорого. Тут нельзя полагаться на одни лишь ясные имена методов и параметров. Думаю, что тут будет полезно описать ещё и сложность/надёжность алгоритмов, их ограничения и т.д.
- Транзакции в БД. Вроде бы базовые операции просты (startTransaction, commit, rollback), но важно описать поведение системы в разных ситуациях, какие ошибки могут возникнуть, в каком состоянии должна быть система после выполнения той или иной операции и т.д.
- Код различных датчиков. Кажется, что у разных датчиков (температура, влажность, напряжение и прочее) может быть не очень сложный код, но вот интерфейс нужно написать качественный, где будут описаны различные значения, пороговые уровни, реакции на эти значения и т.д.   

### Выводы
Кажется, что подходящие типы данных могут сделать интерфейсы более наглядными, например с помощью enum мы можем показать возможные коды ошибок. Более точный тип данных может содержать ответ на ряд вопросов об интерфейсе.   
Есть много случаев когда интерфейс не должен быть проще реализации. Чрезмерное упрощение может привести к разным проблемам, например система может стать менее гибкой и менее простой для дальнейшего развития.
Так что не стоит бояться делать серьёзные интерфейсы.