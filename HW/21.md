### Это не баг
По спецификации нельзя создавать пересекающиеся по времени действия прайс-листы для одной услуги. На фронтенде стоят соответствующие проверки, которые это не допускают. 
Однако на бэке был API-метод, который позволяет нарушить это условие. API-метод не использовали и особо не афишировали, благодаря этому система работала без проблем.

В одном из сценариев длительность подписки на услугу определяется по записи в БД, которая обозначает действующую подписку, услуга теоретически может быть переподписана другим способом и поля
со сроками действия услуги могут быть сброшены. Сейчас такого не происходит потому, что подписка ранее подписанной услуги не практикуется по бизнес-сценариям. По-хорошему период подписки надо запоминать и получать другим образом.

### Это не баг (а что-то другое)
Использование имён переменных, которые не отражают их суть. Наиболее часто встречаюсь с таким в коде после рефакторинга, либо после каких-то доработок текущего решения, когда сначала разработчик 
реализовал одно решение, а потом понял, что можно сделать лучше, внёс правки, но имена переменных не обновил. Вроде и не ошибка, но штука плохая, так как код становится более запутанным.

В нашем проекте до сих пор можно увидеть классы, которые реализуют антипаттерн god-object. Легаси классы, которые работают, и вроде без ошибок, но там так всё запутанно и сложно, что даже страшно открывать их код.
Всё намешано в одну кучу: обработка данных, валидация, походы в БД, формирование ответа и т.д. Видел файл на 2000 строк, причём это не какой-то сервис, а одна единственная команда, код которой свален в кучу.

### Это сбивает людей с толку
Поставщик ТВ-расписания в числе прочего возвращает имя телепередачи. В его ответе есть два поля title и name. Это расписание так или иначе используется 2-я нашими сервисами. 
В нашем коде нужно было лишь значение поля name. Однако в одном из сервисов мы парсили ответ поставщика и сохраняли имя телепрограммы в переменную title. 
А в другом сервисе это обрабатывалось как name. В итоге возникала путаница, поставщик отдаёт title и name, нам нужно лишь name, но в одном из сервисов мы сохраняем его в поле title.
Сходу возникает впечатление, что в наших сервисах поля должны содержать разные значения, но они были одинаковы, так как данные для наших полей брались из name.

В коде используются библиотеки для работы с географическими точками, конструкторы имеют формат Point(double x, double y) или Point(double lat, double lon). 
Но в одних библиотеках на первом месте в конструкторе стоит долгота, а в других -- широта. Сходу кажется, что везде всё должно быть однообразно и всегда на первом месте
в конструкторе точке должна быть широта(ну или долгота), но это не так. И иногда приходится идти в документацию, чтобы понять, а что же должно идти первым в классе из этой библиотеки. Особенно когда переменная обозначается как x или y.

### Это хрупкость
Использование Integer в качестве идентификаторов записей в БД. Долгое время всё было хорошо, но база разрослась и в некоторых таблицах почти закончились числа из диапазона Integer.
Ситуацию удалось разрешить до переполнения, однако сделано это было в последний момент (буквально пара дней и начались бы проблемы).

Даункастинг. Есть какой-то общий класс и у него пока один наследник, в коде есть обработка массива объектов общего класса, в этой обработке 
используется приведение типа общего класса к наследнику, для получения доступа к специфичному методу. В моменте всё работает хорошо, но по мере развития проекта 
у общего класса могут появиться новые наследники, что приведёт к исключениям в работе имеющегося кода.    

### Не соответствует требованиям OSHA 
Думал, что можно привести в пример по этому поводу и довольно быстро вспомнил анекдот про швабры, которые держат потолок под комнатой с ядовитым газом.

В коде есть поля, которые вроде не используются в актуальных взаимодействиях и у нового разработчика на проекте велик соблазн избавиться от неактуального мусора. 
Но оказывается, что в одном из регионов, где применяется приложение есть легаси биллинг, который без этого поля не будет корректно работать. Но об этом знают лишь действующие разработчики, которые на проекте работают уже давно.

В проекте есть http-клиент, один из его методов отправляет в сторонний сервис запрос на отправку сообщения на устройство пользователя. Обычно в методах этого клиента для составления запроса используется UriComponentsBuilder. 
И только код формирования запроса на отправку сообщения использует StringBuilder, чтобы избежать двойного url кодирования текста сообщения, который передаётся в параметре запроса. Новый разработчик может захотеть привести методы к единому виду и заменить StringBuilder на UriComponentsBuilder, 
что приведёт к некорректному отображению сообщений у пользователя. 

### Выводы
Немного изменилось представление о баге. Есть ощущение, что теперь слово баг я буду использовать в меньшем количестве случаев, чем раньше.
Кажется стал лучше понимать, что такое хрупкость кода. Раньше в голове как будто крутилось туманное понимание, а в этом материале увидел неплохое описание хрупкости, которое словами выразило те мои смутные ощущения.  
При написании программы можно допустить ряд ошибок, которые не являются багами. Однако, эти ошибки могут привести к проблемам в будущем.   
Иногда какая-то часть кода может вызывать у нас ощущение, будто в ней что-то не так, но не всегда это можно называть ошибкой.

Не всё то баг, что кажется неверным.
