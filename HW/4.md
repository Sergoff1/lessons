## Пример 1

<details>
<summary>Исходный код</summary>

```Java
@Slf4j
@Service
@RequiredArgsConstructor
public class ExchangeService {

    private final PurchaseParamsValidator purchaseExistsValidator;
    private final ExchangeParamsToPurchaseParamsConverter exchangeParamsConverter;
    private final PurchaseParamsToPurchaseConverter toPurchaseConverter;
    private final PurchaseDtoToPurchaseConverter purchaseDtoToPurchaseConverter;
    private final PurchaseParamsToPurchaseHistoryConverter toPurchaseHistoryConverter;
    private final MessageService messageService;
    private final PurchaseDao purchaseDao;
    private final PurchaseHistoryDao purchaseHistoryDao;

    public void contentExchange(ExchangeParams rawParams) {
        session.doInTransaction(() -> {
            PurchaseParams params = exchangeParamsConverter.convert(rawParams);
            purchaseExistsValidator.validate(params);

            PurchaseDto exchangingContent = purchaseDao.findAllBySanAndFilters(params.getAccount().getAccountNumber(),
                            null, params.getExchangeContentId(), null, CONFIRMED, null, true)
                    .stream()
                    // Берём последнюю запись о покупке контента, который будем менять.
                    .max(Comparator.comparing(PurchaseDto::getCreatedAt))
                    .orElseThrow(() -> new RuntimeException("Не найдено подходящего контента для обмена"));

            long originPurchaseId = wasExchange(exchangingContent)
                    ? exchangingContent.getUsageDetails().getExchange().getOriginPurchaseId()
                    : exchangingContent.getId();

            long exchangeCount = wasExchange(exchangingContent)
                    ? exchangingContent.getUsageDetails().getExchange().getCount() + 1
                    : 1;

            // Проверим, что не достигнут лимит обменов
            if (exchangeCount - 1 >= ConfigurationHelper.getIntProperty("purchase_content.exchange_limit", 10)) {
                throw new PurchaseExchangesLimitReachedException();
            }

            // Если требуемый контент уже подключался, то нужно обновить соответствующую запись, а не создавать новую.
            Optional<PurchaseDto> oldPurchase = purchaseDao.findBy(params.getAccount().getAccountNumber(),
                    params.getContentId(),
                    params.getContentPackage().getId(),
                    params.getContentUsageRule().getId());

            Purchase purchase = toPurchaseConverter.convert(params).toBuilder()
                    .usageDetails(UsageDetails.builder()
                            .type(UsageDetails.Type.EXCHANGE)
                            .exchange(Exchange.builder()
                                    .originPurchaseId(originPurchaseId)
                                    .parentPurchaseId(exchangingContent.getId())
                                    .count(exchangeCount)
                                    .build())
                            .build())
                    .build();

            // Обновим статус покупки, если она есть, или запишем новую покупку
            long purchaseId;
            if (oldPurchase.isPresent()) {
                purchaseId = oldPurchase.get().getId();
                purchaseDao.update(purchaseDtoToPurchaseConverter.convert(oldPurchase.get())
                        .toBuilder()
                        .status(purchase.getStatus())
                        .startDate(purchase.getStartDate())
                        .endDate(purchase.getEndDate())
                        .price(purchase.getPrice())
                        .usageDetails(purchase.getUsageDetails())
                        .build());
            } else {
                purchaseId = purchaseDao.create(purchase);
            }

            // Обновим статус контента, который заменили
            purchaseDao.update(purchaseDtoToPurchaseConverter.convert(exchangingContent).toBuilder()
                    .status(EXCHANGED)
                    .build());

            PurchaseHistoryDto originPurchaseHistory = purchaseHistoryDao.getActiveByPurchaseIdUsageTypeAndStatus(
                    originPurchaseId, PURCHASE, CONFIRMED);

            // Сделаем запись в историю покупок.
            purchaseHistoryDao.create(toPurchaseHistoryConverter.convert(params).toBuilder()
                    .purchaseId(purchaseId)
                    .parentId(originPurchaseHistory.getId())
                    .wsResult("success")
                    .status(CONFIRMED)
                    .usageDetails(purchase.getUsageDetails())
                    .build());

            // Отправляем сообщение для переначитки покупок
            messageService.sendPurchasesChangedNotification(params.getAccount().getAccountNumber());
        });
    }

    private boolean wasExchange(PurchaseDto content) {
        return content.getUsageDetails() != null && content.getUsageDetails().getType() == UsageDetails.Type.EXCHANGE;
    }
}

@Component
@RequiredArgsConstructor
public class PurchaseParamsValidator implements Validator<PurchaseParams> {
    private final PurchaseDao purchaseDao;

    @Override
    public void validate(PurchaseParams params) {
        // Уникальность записей определяется комбинацией полей, позволяющей учитывать контент
        // с различной моделью потребления (TVOD, EST) и качества ассета (4K, HD, SD).
        // ContentUsageRule определяет и модель, и качество.
        boolean isPurchaseExists = purchaseDao.exists(
                params.getAccount().getAccountNumber(),
                params.getContentId(),
                params.getContentPackage().getId(),
                params.getContentUsageRule().getId());
        if (isPurchaseExists) {
            throw new PuchaseAlreadyBeenMadeException();
        }
    }
}
```

</details>

#### Логический дизайн
Цель:
Обменять купленный контент на новый, который на данный момент недоступен пользователю.

Пользователь купил какой-то контент и инициировал процедуру его обмена. Обменять можно не всё и не всегда, но что и когда можно обменять решает другой сервис.
Если запрос на обмен пришёл к нам, то можно быть уверенным, что обмениваемый контент куплен и на его замену выбран допустимый вариант.

Для обмена нужно убедиться, что новый контент ещё не куплен пользователем, иначе следует вернуть ошибку с кодом 2 и сообщением о том, что выбранный контент уже куплен.
Контент считается купленным, если он находится в статусе temporary или confirmed и время окончания действия покупки больше текущей даты.

Допускается совершать цепочку обменов, поэтому нужно убедиться, что пользователь не достиг лимита цепочки обменов.
Если лимит исчерпан нужно вернуть ошибку с кодом 5 и сообщением "Превышено доступное количество обмена фильма"

Обмениваемый фильм может быть куплен неоднократно (например сначала купили в HD качестве, потом в 4K), в таком случае менять нужно последний приобретённый вариант.  

Для обмена следует
создать новую запись о подключении выбранного фильма или обновить существующую (пользователь мог купить этот фильм в прошлом,
но сейчас он стал недоступным для просмотра, например потому что закончился срок действия покупки) в таблице PURCHASE.
Обновить статус фильма, который заменили (назначить статус exchanged), сделав его недоступным для просмотра.
Сохранить запись о подключении нового фильма в историю покупок пользователя. Добавить информацию о подключении контента в таблицу PURCHASE_HISTORY, которая базируется на основе записи в PURCHASE, созданной ранее.
Опубликовать сообщение о том, что на учётной записи изменился список покупок, чтобы другие сервисы выполнили переначитку доступного контента.

##### Оценка соответствия дизайну
Я не совсем понимаю насколько подробно нужно описывать логический дизайн. 
Должны ли там быть описаны поля и значения, которые нужно сохранить в БД или же такой дизайн подразумевает описание поведения системы на высоком уровне.   
Если исходить из того, что логический дизайн это скорее высокоуровневое описание поведения системы, то кажется, что в целом код соответствует логическому дизайну.
В коде есть разные конвертации параметров из одного типа в другой, но кажется, что это скорее детали реализации. 
Хотя если в дизайне могут различаться детали реализации, то код и дизайн не соответствуют друг другу в формате 1:1, а это наводит на мысль, что я криво описал дизайн или недостаточно хорошо сделан код.

Из улучшений можно было бы усилить соответствие кода дизайну отказавшись от довольно универсального (ряд его параметров не используется) метода поиска подключенного контента в БД, заменив его на специализированный метод с более говорящим именем.
Также выделил часть логики в отдельные функции, чтобы код основного метода был более выразительным. Благодаря этому код метода стал ближе к словесному дизайну.

<details>
<summary>Обновлённый код</summary>

```Java
@Slf4j
@Service
@RequiredArgsConstructor
public class ExchangeService {

    private final PurchaseParamsValidator purchaseExistsValidator;
    private final ExchangeParamsToPurchaseParamsConverter exchangeParamsConverter;
    private final PurchaseParamsToPurchaseConverter toPurchaseConverter;
    private final PurchaseDtoToPurchaseConverter purchaseDtoToPurchaseConverter;
    private final PurchaseParamsToPurchaseHistoryConverter toPurchaseHistoryConverter;
    private final MessageService messageService;
    private final PurchaseDao purchaseDao;
    private final PurchaseHistoryDao purchaseHistoryDao;

    public void contentExchange(ExchangeParams rawParams) {
        session.doInTransaction(() -> {
            PurchaseParams params = exchangeParamsConverter.convert(rawParams);
            purchaseExistsValidator.validate(params);

            PurchaseDto exchangingContent = purchaseDao.findLastActiveByContentId(params.getAccount().getAccountNumber(), 
                            params.getExchangeContentId());

            long exchangeCount = wasExchange(exchangingContent)
                    ? exchangingContent.getUsageDetails().getExchange().getCount() + 1
                    : 1;

            // Проверим, что не достигнут лимит обменов
            if (exchangeCount - 1 >= ConfigurationHelper.getIntProperty("purchase_content.exchange_limit", 10)) {
                throw new PurchaseExchangesLimitReachedException();
            }

            Purchase purchase = toPurchaseConverter.convert(params).toBuilder()
                    .usageDetails(UsageDetails.builder()
                            .type(UsageDetails.Type.EXCHANGE)
                            .exchange(Exchange.builder()
                                    .originPurchaseId(getOriginPurchaseId(exchangingContent))
                                    .parentPurchaseId(exchangingContent.getId())
                                    .count(exchangeCount)
                                    .build())
                            .build())
                    .build();

            //Создать запись о покупке контента в результате обмена
            long purchaseId = mergePurchase(params, purchase);

            // Обновим статус контента, который заменили
            purchaseDao.update(purchaseDtoToPurchaseConverter.convert(exchangingContent).toBuilder()
                    .status(EXCHANGED)
                    .build());

            PurchaseHistoryDto originPurchaseHistory = purchaseHistoryDao.getActiveByPurchaseIdUsageTypeAndStatus(
                    getOriginPurchaseId(exchangingContent), PURCHASE, CONFIRMED);

            // Сделаем запись в историю покупок.
            purchaseHistoryDao.create(toPurchaseHistoryConverter.convert(params).toBuilder()
                    .purchaseId(purchaseId)
                    .parentId(originPurchaseHistory.getId())
                    .wsResult("success")
                    .status(CONFIRMED)
                    .usageDetails(purchase.getUsageDetails())
                    .build());

            // Отправляем сообщение для переначитки покупок
            messageService.sendPurchasesChangedNotification(params.getAccount().getAccountNumber());
        });
    }

    private boolean wasExchange(PurchaseDto content) {
        return content.getUsageDetails() != null && content.getUsageDetails().getType() == UsageDetails.Type.EXCHANGE;
    }

    private long mergePurchase(PurchaseParams params, Purchase purchase) {
        // Если требуемый контент уже подключался, то нужно обновить соответствующую запись, а не создавать новую.
        Optional<PurchaseDto> oldPurchase = purchaseDao.findBy(params.getAccount().getAccountNumber(),
                params.getContentId(),
                params.getContentPackage().getId(),
                params.getContentUsageRule().getId());

        // Обновим статус покупки, если она есть, или запишем новую покупку
        long purchaseId;
        if (oldPurchase.isPresent()) {
            purchaseId = oldPurchase.get().getId();
            purchaseDao.update(purchaseDtoToPurchaseConverter.convert(oldPurchase.get())
                    .toBuilder()
                    .status(purchase.getStatus())
                    .startDate(purchase.getStartDate())
                    .endDate(purchase.getEndDate())
                    .price(purchase.getPrice())
                    .usageDetails(purchase.getUsageDetails())
                    .build());
        } else {
            purchaseId = purchaseDao.create(purchase);
        }

        return purchaseId;
    }

    private long getOriginPurchaseId(PurchaseDto exchangingContent) {
        return wasExchange(exchangingContent)
                ? exchangingContent.getUsageDetails().getExchange().getOriginPurchaseId()
                : exchangingContent.getId();
    }
}

@Component
@RequiredArgsConstructor
public class PurchaseParamsValidator implements Validator<PurchaseParams> {
    private final PurchaseDao purchaseDao;

    @Override
    public void validate(PurchaseParams params) {
        // Уникальность записей определяется комбинацией полей, позволяющей учитывать контент
        // с различной моделью потребления (TVOD, EST) и качества ассета (4K, HD, SD).
        // ContentUsageRule определяет и модель, и качество.
        boolean isPurchaseExists = purchaseDao.exists(
                params.getAccount().getAccountNumber(),
                params.getContentId(),
                params.getContentPackage().getId(),
                params.getContentUsageRule().getId());
        if (isPurchaseExists) {
            throw new PuchaseAlreadyBeenMadeException();
        }
    }
}
```

</details>

На итерацию потрачено около 10 часов. Основные сложности возникли с описанием словесного дизайна. Долго думал, что же там следует отразить. Какие части кода вообще брать, как это должно быть устроено.
Кажется, что первый пример вышел не очень хорошим, поскольку я взял слишком мелкую часть кода.


## Пример 2

<details>
<summary>Исходный код</summary>

```Java
@Builder(toBuilder = true)
@Slf4j
@Service
@RequiredArgsConstructor
public class OnetimeSubscriptionOssService {

    public static final int PURCHASE_ERROR_CODE = -2;
    public static final String ONE_TIME_REQUEST_WS_COMMENT = "by request_subscribe_on ws";
    public static final String ONE_TIME_SUBSCRIBE_WS_COMMENT = "by purchase_request_v2 ws";
    public static final String ONETIME_PENDING_REQUEST_COMMENT = "Заявка создана и исполнена по команде из приложения";

    private static final int DAYS_IN_MONTH = 30;

    private final ExecutionContext ctx;
    private final PendingRequestDao pendingRequestDao;
    private final MessageService messageService;
    private final BillingClientFactory billingClientFactory;
    private final UniClientExceptionFactory uniClientExceptionFactory;
    private final ServiceSubscriberFactory serviceSubscriberFactory;
    private final HotezaService hotezaService;
    private final ServiceUsageDao serviceUsageDao;
    private final ServiceAccountDao serviceAccountDao;
    private final OssDaoFacade ossDaoFacade;
    private final DiscountServiceDao discountServiceDao;
    private final ExtraInfoConverter extraInfoConverter;
    private final DeviceTypeService deviceTypeService;
    private final HotelService hotelService;

    /**
     * Выполнить разовую подписку услуги. Валидация входящих параметров не производится.
     *
     * @param priceList прайс-лист, по которому подключается услуга.
     */
    public RequestSubscribeResult subscribe(ServiceAccountProps serviceAccount, ServiceSpecDto serviceSpec,
                                            TerminalDto terminal, PriceListDto priceList, boolean isAdminUiNotify) {
        final Session session = ctx.getSession();
        final DiscountInfo discountInfo = findDiscountInfo(serviceAccount, serviceSpec, priceList);
        final int purchasePrice = discountInfo == null
                ? priceList.getPrice()
                : discountInfo.getDiscountPriceList().getPrice();
        final LocalDateTime startDate = LocalDateTime.now();
        final int days = priceList.getDays() != null ? priceList.getDays() : priceList.getMonths() * DAYS_IN_MONTH;
        final SubscribeParametersBuilder subscribeParamsBuilder = SubscribeParameters.builder()
                .account(serviceAccount)
                .serviceSpec(serviceSpec)
                .terminal(terminal)
                .priceList(priceList)
                .startDate(startDate)
                .stopDate(startDate.plusDays(days))
                .overridePrice(purchasePrice)
                .discountInfo(discountInfo)
                .isAdminUiNotify(isAdminUiNotify)
                .sourceType(SourceType.OSS_BILLING);

        return session.doInTransaction(() -> {
            HttpServletRequest request = ctx.getRequest();
            // Произвести разовую покупку подписки в биллинге.
            // Операция выполняется в отдельном контексте, что бы зафиксировать обращение в биллинг в истории подписок.
            ThreadScopeRunner.run(() -> {
                try (ExecutionContext ignored = ctx) {
                    ctx.setRequest(request);
                    ctx.getSession().startTransaction();
                    try {
                        return makeOssPurchase(subscribeParamsBuilder.build());
                    } finally {
                        ctx.getSession().commit();
                    }
                }
            });

            //Подключить услугу
            serviceSubscriberFactory.get(serviceSpec.getDiscriminator(), true, true)
                    .subscribeService(subscribeParamsBuilder
                            .wsComment(ONE_TIME_SUBSCRIBE_WS_COMMENT)
                            .build());

            //Списать средства с внутреннего баланса УЗ гостиницы и послать нотификацию в Hoteza
            if (serviceAccount.getType().isB2b()) {
                hotelService.updateBalance(serviceAccount.getAccountNumber(), purchasePrice);
                hotezaService.purchaseAsync(serviceAccount.getAccountNumber(), serviceSpec.getName(), purchasePrice);
            }

            //Сохранить запись в истории заявок об успешном выполнении
            long requestId = createSuccessPendingRequest(serviceAccount.getId(), serviceSpec.getId(),
                    terminal.getId());

            //Послать нотификацию о созданной заявке, для единообразной обработки на стороне ...
            messageService.subscribeRequestChanged(serviceAccount.getAccountNumber(),
                    serviceSpec.getId());

            return RequestSubscribeResult.builder()
                    .setServiceSpecIId(serviceSpec.getInternalId())
                    .setRequestState(RequestState.DONE)
                    .setUsageType(PendingRequest.UsageType.SUBSCRIBE)
                    .setServiceSpecId(serviceSpec.getId())
                    .setPendingRequestId(requestId)
                    .build();
        });
    }

    private DiscountInfo findDiscountInfo(ServiceAccountProps serviceAccount,
                                          ServiceSpecDto serviceSpec,
                                          PriceListDto priceList) {
        // Ищем подключенные услуги скидки, скидочные one-time прайс-листы на них с той же длительностью, что и основной.
        List<DiscountServiceInfo> discountServices = discountServiceDao
                .findDiscountServicesForOss(serviceAccount.getId(), serviceSpec.getId());

        PriceListLite discountPriceList = discountServices.stream()
                .filter(dsi -> dsi.getPriceList().isOneTime())
                .filter(dsi -> PriceListHelper.sameDays(priceList.getDays(), dsi.getPriceList())
                               || PriceListHelper.sameMonths(priceList.getMonths(), dsi.getPriceList()))
                .map(DiscountServiceInfo::getPriceList)
                .min(Comparator.comparingInt(PriceListLite::getPrice))
                .orElse(null);

        ServiceSpecLite discountServiceSpec = discountServices.stream()
                .filter(dpl -> dpl.getPriceList() == discountPriceList)
                .findFirst()
                .map(DiscountServiceInfo::getServiceSpec)
                .orElse(null);

        if (discountPriceList == null || discountServiceSpec == null) {
            return null;
        }

        return new DiscountInfo(discountServiceSpec, discountPriceList, priceList.getPrice());
    }

    /**
     * Проверить, не произойдет ли превышение лимита покупок при подключении новой услуги.
     *
     * @param serviceAccount учетная запись B2B
     * @param price          стоимость, которая будет списана с внутреннего баланса УЗ
     */
    private void checkB2bBalance(ServiceAccountProps serviceAccount, int price) {
        if (!hotelService.checkAccountLimit(price, true,
                serviceAccount.getBalance() != null ? serviceAccount.getBalance() : 0,
                serviceAccount.getPayLimit() != null ? serviceAccount.getPayLimit() : 0)) {
            throw new AccountBalanceLimitOverflowException(serviceAccount.getLanguage());
        }
    }

    private ServiceUsage makeOssPurchase(SubscribeParameters oneTimeParams) {
        final ServiceUsageDao serviceUsageDao = new ServiceUsageDbDao();

        PriceListDto priceList = oneTimeParams.getPriceList();
        ServiceAccountProps account = oneTimeParams.getAccount();
        ServiceSpecDto serviceSpec = oneTimeParams.getServiceSpec();
        TerminalDto terminal = oneTimeParams.getTerminal();
        Date startDate = DateUtils.valueOf(oneTimeParams.getStartDate());
        Date stopDate = DateUtils.valueOf(oneTimeParams.getStopDate());

        // Создать запись в истории о запросе на подписку c дискриминатором SUBSCRIPTIONSERVICEREQUEST
        // Запись с дискриминатором SUBSCRIPTIONSERVICEUSAGE будет создана в случае успешной подписки
        ServiceUsage serviceUsage = ServiceUsage.builder()
                .setId(serviceUsageDao.getNextServiceUsageId(ctx.getSession()))
                .setDiscriminator(ServiceUsage.DISCRIMINATOR_SUBSCRIPTION_REQUEST)
                .setStartDate(startDate)
                .setUsageDate(startDate)
                .setStopDate(stopDate)
                .setUsageType(PendingRequest.UsageType.SUBSCRIBE.getCode())
                .setServiceAccountId(account.getId())
                .setServiceSpec(serviceSpec)
                .setPrice(oneTimeParams.getOverridePrice())
                .setDeviceTypeId(terminal.getDeviceTypeId())
                .setMacAddress(terminal.getMac())
                .setResourceInfo(new ServiceUsage.ResourceInfo(terminal.getId()))
                .setSourceType(SourceType.OSS_BILLING)
                .setPriceListId(priceList.getId())
                .setNotifyOss(true)
                .setUserIp(ctx.getForwardedForHeader())
                .setExtraInfo(extraInfoConverter.convert(oneTimeParams))
                .build();
        serviceUsageDao.createServiceUsage(ctx.getSession(), serviceUsage);
        //Получить тип устройства для биллинга
        String deviceType = deviceTypeService.getBillingDeviceType(terminal.getDeviceTypeExtId(),
                terminal.getDiscriminator());

        try {
            //Проверить баланс гостиничной УЗ
            if (account.getType().isB2b()) {
                checkB2bBalance(account, priceList.getPrice());
            }

            UniBillingClient uniBillingClient = billingClientFactory.getUniBillingClient(account.getAccountNumber());
            WsResult wsResult = uniBillingClient.purchaseV2(String.valueOf(serviceUsage.getId()),
                    account, serviceSpec, serviceSpec.getName(),
                    String.valueOf(oneTimeParams.getOverridePrice()), deviceType, null);

            if (wsResult.hasError()) {
                throw uniClientExceptionFactory.apply(wsResult);
            }

            //Записать успешный ответ биллинга, для adminui код "0" переопределяется на "1"
            ServiceUsage confirmedServiceUsage = serviceUsage.toBuilder()
                    .setWsResult(ServiceUsage.WS_RESULT_SUCCESS_CODE)
                    .setWsComment(ONE_TIME_REQUEST_WS_COMMENT)
                    .build();
            serviceUsageDao.update(ctx.getSession(), confirmedServiceUsage);
            return confirmedServiceUsage;

        } catch (AccountBalanceLimitOverflowException e) {
            serviceUsageDao.update(ctx.getSession(), serviceUsage.toBuilder()
                    .setWsResult(PURCHASE_ERROR_CODE)
                    .setWsComment(e.getMessage())
                    .build());
            throw e;
        } catch (UniClientException e) {
            serviceUsageDao.update(ctx.getSession(), serviceUsage.toBuilder()
                    .setWsResult(ServiceUsage.WS_RESULT_ERROR_CODE)
                    .setWsComment(e.getMessage())
                    .build());
            throw e;
        } catch (ConnectionOrReadTimeoutException e) {
            serviceUsageDao.update(ctx.getSession(), serviceUsage.toBuilder()
                    .setWsResult(PURCHASE_ERROR_CODE)
                    .setWsComment(BILLING_TIMEOUT_TEXT)
                    .build());
            throw new BillingPurchaseTimeoutOssException();
        } catch (Exception e) {
            serviceUsageDao.update(ctx.getSession(), serviceUsage.toBuilder()
                    .setWsResult(PURCHASE_ERROR_CODE)
                    .setWsComment(e.getLocalizedMessage())
                    .build());
            throw new RuntimeException(e.getLocalizedMessage(), e);
        }
    }

    private long createSuccessPendingRequest(long serviceAccountId, long serviceSpecId, long terminalId) {
        PendingRequest pendingRequest = PendingRequest.builder()
                .discriminator(PendingRequest.DISCRIMINATOR_PENDING_SERVICE_REQUEST)
                .requestState(RequestState.DONE)
                .createdAt(new Date())
                .terminalId(terminalId)
                .serviceSpecId(serviceSpecId)
                .serviceAccountId(serviceAccountId)
                .usageType(PendingRequest.UsageType.SUBSCRIBE)
                .build();

        long requestId = pendingRequestDao.create(pendingRequest);
        pendingRequestDao.savePendingRequestHistory(requestId, null, RequestState.DONE, terminalId,
                ONETIME_PENDING_REQUEST_COMMENT);

        return requestId;
    }

}

```

</details>

#### Логический дизайн
Цель: Подключить пользователю разовую услугу (она подключается на определённый срок и у неё нет автопродления).
Предусловие: услуга подключается на существующее устройство и переданный в качестве параметра прайс-лист является разовым и у него указан срок подключения услуги.

Определить цену подписки:
Проверить есть ли у пользователя скидки для подключаемой услуги. 
Если скидок несколько, то берём прайс-лист с минимальной ценой. Скидочный прайс-лист должен совпадать по длительности подключения услуги с основным прайс-листом.
Если скидок нет, то берём цену из переданного в параметрах прайс-листа.

Определить срок подключения услуги:
В прайс-листе должен быть заполнен срок, на который подключается услуга по этому прайс-листу. Количество дней или месяцев (гарантировано, что заполнено что-то одно).

Если пользователь является постояльцем гостиницы, то перед запросом на списание денежных средств в биллинг нужно убедиться, что он у него хватит доступного лимита на покупку.
В случае если при покупке лимит будет превышен, то нужно отправить пользователю соответствующую ошибку.

Отправить в биллинг запрос на подключение услуги (биллинг спишет необходимую сумму со счёта пользователя).
Сохранить в истории использования услуг запись о запросе на подключение услуги через биллинг (в записи должна содержаться информация об ответе от биллинга).
В случае ошибок вернуть пользователю соответствующее сообщение.

После списания денег и успешного ответа от биллинга выполнить подключение услуги пользователю.
Если пользователь является постояльцем гостиницы, то нужно списать деньги с гостиничного счёта и передать данные о покупке в PMS-систему.

Сохранить информацию об успешном выполнении заявки на подключение услуги в истории заявок.

Отправить нотификацию о создании заявки на подключение услуги.

Вернуть ответ о создании заявки на подключение услуги. Заявка должна быть в статусе "Исполнено". 


##### Оценка соответствия дизайну
Код по большому счёту соответствует логическому дизайну.

Сделал пару действий, которые ещё больше приближают его реализацию к дизайну.
Теперь запись в историю подключения услуг сохраняется один раз, после обращения к биллингу, как это описано в дизайне (раньше сохраняли предварительную версию, а после ответа от биллинга делали обновление этой записи, было два обращения к БД),
убрал одно обращение к БД.
Избавился от избыточного объявления ДАО serviceUsageDao через new, теперь этим управляет Спринг. 

Затрачено около 4 часов, на описание логического дизайна (чтобы разобраться, что и зачем делается) и поиск того, что можно было бы улучшить.
<details>
<summary>Обновлённый код</summary>

```Java
@Builder(toBuilder = true)
@Slf4j
@Service
@RequiredArgsConstructor
public class OnetimeSubscriptionOssService {

    public static final int PURCHASE_ERROR_CODE = -2;
    public static final String ONE_TIME_REQUEST_WS_COMMENT = "by request_subscribe_on ws";
    public static final String ONE_TIME_SUBSCRIBE_WS_COMMENT = "by purchase_request_v2 ws";
    public static final String ONETIME_PENDING_REQUEST_COMMENT = "Заявка создана и исполнена по команде из приложения";

    private static final int DAYS_IN_MONTH = 30;

    private final ExecutionContext ctx;
    private final PendingRequestDao pendingRequestDao;
    private final MessageService messageService;
    private final BillingClientFactory billingClientFactory;
    private final UniClientExceptionFactory uniClientExceptionFactory;
    private final ServiceSubscriberFactory serviceSubscriberFactory;
    private final HotezaService hotezaService;
    private final ServiceUsageDao serviceUsageDao;
    private final ServiceAccountDao serviceAccountDao;
    private final OssDaoFacade ossDaoFacade;
    private final DiscountServiceDao discountServiceDao;
    private final ExtraInfoConverter extraInfoConverter;
    private final DeviceTypeService deviceTypeService;
    private final HotelService hotelService;

    /**
     * Выполнить разовую подписку услуги. Валидация входящих параметров не производится.
     *
     * @param priceList прайс-лист, по которому подключается услуга.
     */
    public RequestSubscribeResult subscribe(ServiceAccountProps serviceAccount, ServiceSpecDto serviceSpec,
                                            TerminalDto terminal, PriceListDto priceList, boolean isAdminUiNotify) {
        final Session session = ctx.getSession();
        final DiscountInfo discountInfo = findDiscountInfo(serviceAccount, serviceSpec, priceList);
        final int purchasePrice = discountInfo == null
                ? priceList.getPrice()
                : discountInfo.getDiscountPriceList().getPrice();
        final LocalDateTime startDate = LocalDateTime.now();
        final int days = priceList.getDays() != null ? priceList.getDays() : priceList.getMonths() * DAYS_IN_MONTH;
        final SubscribeParametersBuilder subscribeParamsBuilder = SubscribeParameters.builder()
                .account(serviceAccount)
                .serviceSpec(serviceSpec)
                .terminal(terminal)
                .priceList(priceList)
                .startDate(startDate)
                .stopDate(startDate.plusDays(days))
                .overridePrice(purchasePrice)
                .discountInfo(discountInfo)
                .isAdminUiNotify(isAdminUiNotify)
                .sourceType(SourceType.OSS_BILLING);

        return session.doInTransaction(() -> {
            HttpServletRequest request = ctx.getRequest();
            // Произвести разовую покупку подписки в биллинге.
            // Операция выполняется в отдельном контексте, что бы зафиксировать обращение в биллинг в истории подписок.
            ThreadScopeRunner.run(() -> {
                try (ExecutionContext ignored = ctx) {
                    ctx.setRequest(request);
                    ctx.getSession().startTransaction();
                    try {
                        return makeOssPurchase(subscribeParamsBuilder.build());
                    } finally {
                        ctx.getSession().commit();
                    }
                }
            });

            //Подключить услугу
            serviceSubscriberFactory.get(serviceSpec.getDiscriminator(), true, true)
                    .subscribeService(subscribeParamsBuilder
                            .wsComment(ONE_TIME_SUBSCRIBE_WS_COMMENT)
                            .build());

            //Списать средства с внутреннего баланса УЗ гостиницы и послать нотификацию в Hoteza
            if (serviceAccount.getType().isB2b()) {
                hotelService.updateBalance(serviceAccount.getAccountNumber(), purchasePrice);
                hotezaService.purchaseAsync(serviceAccount.getAccountNumber(), serviceSpec.getName(), purchasePrice);
            }

            //Сохранить запись в истории заявок об успешном выполнении
            long requestId = createSuccessPendingRequest(serviceAccount.getId(), serviceSpec.getId(),
                    terminal.getId());

            //Послать нотификацию о созданной заявке, для единообразной обработки на стороне ...
            messageService.subscribeRequestChanged(serviceAccount.getAccountNumber(),
                    serviceSpec.getId());

            return RequestSubscribeResult.builder()
                    .setServiceSpecIId(serviceSpec.getInternalId())
                    .setRequestState(RequestState.DONE)
                    .setUsageType(PendingRequest.UsageType.SUBSCRIBE)
                    .setServiceSpecId(serviceSpec.getId())
                    .setPendingRequestId(requestId)
                    .build();
        });
    }

    private DiscountInfo findDiscountInfo(ServiceAccountProps serviceAccount,
                                          ServiceSpecDto serviceSpec,
                                          PriceListDto priceList) {
        // Ищем подключенные услуги скидки, скидочные one-time прайс-листы на них с той же длительностью, что и основной.
        List<DiscountServiceInfo> discountServices = discountServiceDao
                .findDiscountServicesForOss(serviceAccount.getId(), serviceSpec.getId());

        PriceListLite discountPriceList = discountServices.stream()
                .filter(dsi -> dsi.getPriceList().isOneTime())
                .filter(dsi -> PriceListHelper.sameDays(priceList.getDays(), dsi.getPriceList())
                               || PriceListHelper.sameMonths(priceList.getMonths(), dsi.getPriceList()))
                .map(DiscountServiceInfo::getPriceList)
                .min(Comparator.comparingInt(PriceListLite::getPrice))
                .orElse(null);

        ServiceSpecLite discountServiceSpec = discountServices.stream()
                .filter(dpl -> dpl.getPriceList() == discountPriceList)
                .findFirst()
                .map(DiscountServiceInfo::getServiceSpec)
                .orElse(null);

        if (discountPriceList == null || discountServiceSpec == null) {
            return null;
        }

        return new DiscountInfo(discountServiceSpec, discountPriceList, priceList.getPrice());
    }

    /**
     * Проверить, не произойдет ли превышение лимита покупок при подключении новой услуги.
     *
     * @param serviceAccount учетная запись B2B
     * @param price          стоимость, которая будет списана с внутреннего баланса УЗ
     */
    private void checkB2bBalance(ServiceAccountProps serviceAccount, int price) {
        if (!hotelService.checkAccountLimit(price, true,
                serviceAccount.getBalance() != null ? serviceAccount.getBalance() : 0,
                serviceAccount.getPayLimit() != null ? serviceAccount.getPayLimit() : 0)) {
            throw new AccountBalanceLimitOverflowException(serviceAccount.getLanguage());
        }
    }

    private ServiceUsage makeOssPurchase(SubscribeParameters oneTimeParams) {
        PriceListDto priceList = oneTimeParams.getPriceList();
        ServiceAccountProps account = oneTimeParams.getAccount();
        ServiceSpecDto serviceSpec = oneTimeParams.getServiceSpec();
        TerminalDto terminal = oneTimeParams.getTerminal();
        Date startDate = DateUtils.valueOf(oneTimeParams.getStartDate());
        Date stopDate = DateUtils.valueOf(oneTimeParams.getStopDate());

        // Создать запись в истории о запросе на подписку c дискриминатором SUBSCRIPTIONSERVICEREQUEST
        // Запись с дискриминатором SUBSCRIPTIONSERVICEUSAGE будет создана в случае успешной подписки
        ServiceUsage serviceUsage = ServiceUsage.builder()
                .setId(serviceUsageDao.getNextServiceUsageId(ctx.getSession()))
                .setDiscriminator(ServiceUsage.DISCRIMINATOR_SUBSCRIPTION_REQUEST)
                .setStartDate(startDate)
                .setUsageDate(startDate)
                .setStopDate(stopDate)
                .setUsageType(PendingRequest.UsageType.SUBSCRIBE.getCode())
                .setServiceAccountId(account.getId())
                .setServiceSpec(serviceSpec)
                .setPrice(oneTimeParams.getOverridePrice())
                .setDeviceTypeId(terminal.getDeviceTypeId())
                .setMacAddress(terminal.getMac())
                .setResourceInfo(new ServiceUsage.ResourceInfo(terminal.getId()))
                .setSourceType(SourceType.OSS_BILLING)
                .setPriceListId(priceList.getId())
                .setNotifyOss(true)
                .setUserIp(ctx.getForwardedForHeader())
                .setExtraInfo(extraInfoConverter.convert(oneTimeParams))
                .build();
        //Получить тип устройства для биллинга
        String deviceType = deviceTypeService.getBillingDeviceType(terminal.getDeviceTypeExtId(),
                terminal.getDiscriminator());

        try {
            //Проверить баланс гостиничной УЗ
            if (account.getType().isB2b()) {
                checkB2bBalance(account, priceList.getPrice());
            }

            UniBillingClient uniBillingClient = billingClientFactory.getUniBillingClient(account.getAccountNumber());
            WsResult wsResult = uniBillingClient.purchaseV2(String.valueOf(serviceUsage.getId()),
                    account, serviceSpec, serviceSpec.getName(),
                    String.valueOf(oneTimeParams.getOverridePrice()), deviceType, null);

            if (wsResult.hasError()) {
                throw uniClientExceptionFactory.apply(wsResult);
            }

            //Записать успешный ответ биллинга, для adminui код "0" переопределяется на "1"
            ServiceUsage confirmedServiceUsage = serviceUsage.toBuilder()
                    .setWsResult(ServiceUsage.WS_RESULT_SUCCESS_CODE)
                    .setWsComment(ONE_TIME_REQUEST_WS_COMMENT)
                    .build();
            serviceUsageDao.createServiceUsage(ctx.getSession(), confirmedServiceUsage);
            return confirmedServiceUsage;

        } catch (AccountBalanceLimitOverflowException e) {
            serviceUsageDao.createServiceUsage(ctx.getSession(), serviceUsage.toBuilder()
                    .setWsResult(PURCHASE_ERROR_CODE)
                    .setWsComment(e.getMessage())
                    .build());
            throw e;
        } catch (UniClientException e) {
            serviceUsageDao.createServiceUsage(ctx.getSession(), serviceUsage.toBuilder()
                    .setWsResult(ServiceUsage.WS_RESULT_ERROR_CODE)
                    .setWsComment(e.getMessage())
                    .build());
            throw e;
        } catch (ConnectionOrReadTimeoutException e) {
            serviceUsageDao.createServiceUsage(ctx.getSession(), serviceUsage.toBuilder()
                    .setWsResult(PURCHASE_ERROR_CODE)
                    .setWsComment(BILLING_TIMEOUT_TEXT)
                    .build());
            throw new BillingPurchaseTimeoutOssException();
        } catch (Exception e) {
            serviceUsageDao.createServiceUsage(ctx.getSession(), serviceUsage.toBuilder()
                    .setWsResult(PURCHASE_ERROR_CODE)
                    .setWsComment(e.getLocalizedMessage())
                    .build());
            throw new RuntimeException(e.getLocalizedMessage(), e);
        }
    }

    private long createSuccessPendingRequest(long serviceAccountId, long serviceSpecId, long terminalId) {
        PendingRequest pendingRequest = PendingRequest.builder()
                .discriminator(PendingRequest.DISCRIMINATOR_PENDING_SERVICE_REQUEST)
                .requestState(RequestState.DONE)
                .createdAt(new Date())
                .terminalId(terminalId)
                .serviceSpecId(serviceSpecId)
                .serviceAccountId(serviceAccountId)
                .usageType(PendingRequest.UsageType.SUBSCRIBE)
                .build();

        long requestId = pendingRequestDao.create(pendingRequest);
        pendingRequestDao.savePendingRequestHistory(requestId, null, RequestState.DONE, terminalId,
                ONETIME_PENDING_REQUEST_COMMENT);

        return requestId;
    }

}
```

</details>


## Пример 3

<details>
<summary>Исходный код</summary>

```Java
@Service
@Slf4j
@AllArgsConstructor
@Builder(toBuilder = true)
public class BonusProgramService {

    private static int USER_NOT_FOUND = 3;

    public static final long ERROR_WS_RESULT = 0L;
    public static final long SUCCESS_WS_RESULT = 1L;
    public static final int TIMEOUT_WS_RESULT = -2;
    public static final int HOURS_PER_DAY = 24;
    public static final String WS_COMMENT_TIMEOUT_TEXT = "Таймаут при обращении в бонусную систему";
    public static final String SERVICE_BONUS_DISCRIMINATOR_SUBSCRIBER = "SERVICEBONUS";

    private final ExecutionContext ctx;
    private final BonusProgramClient bonusClient;
    private final BonusProgramUsageDbDao bonusProgramUsageDbDao;
    private final BonusProgramDao bonusProgramDao;
    private final MessageService messageService;
    private final ServiceUsageDao serviceUsageDao;
    private final PurchaseDao purchaseDao;
    private final PurchaseHistoryDao purchaseHistoryDao;
    
    public BonusProgramAddResultDto addBonusProgram(BonusProgramAddParams params) {
        return ctx.getSession().doInTransaction(() -> {

            final ServiceAccountProps account = params.getServiceAccountProps();
            Optional<BonusProgramDto> optionalBonusProgramDto = bonusProgramDao
                    .findByBonusProgramIdAndServiceAccountId(
                            params.getBonusProgramSpecDto().getId(), account.getId());
            boolean isBonusProgramPresent = optionalBonusProgramDto.isPresent();
            if (isBonusProgramPresent) {
                BonusProgramDto bonusProgramDto = optionalBonusProgramDto.get();
                if (bonusProgramDto.isActive()) {
                    return BonusProgramAddResultDto.builder()
                            .status(bonusProgramDto.getStatus().name())
                            .build();
                }
            }

            // Отправить в бонусную систему (через ...) запрос ...
            BonusProgramResponse responseDto;
            try {
                responseDto = bonusClient.addBonusProgram(BonusProgramRequest.builder()
                        .serviceAccountNumber(account.getAccountNumber())
                        .bonusProgramExternalId(params.getBonusProgramSpecDto().getExternalId())
                        .regionExternalId(params.getLocationDto().getExternalId())
                        .login(params.getLogin())
                        .loginType(params.getLoginType())
                        .serviceType(params.getServiceProviderInBonusProgramDto().getServiceType().name())
                        .build());
            } catch (ConnectionOrReadTimeoutException e) {
                // Сохраняем результат в отдельной транзакции, чтобы он сохранился после отката основной транзакции
                ThreadScopeRunner.run(() -> ctx.getSession().doInTransaction(() -> saveTimeoutEvent(params)));
                log.error(e.getLocalizedMessage());
                // "возвращаем в ... ошибку с кодом 4 и сообщением о таймауте"
                throw new SmtubeException(BONUS_PROGRAM_TIMEOUT_ERROR);
            }

            // В случае получения от бонусной системы ответа с ошибкой вернуть ответ с ошибкой
            boolean isSuccessResponse = responseDto.getCode() == 0;
            if (!isSuccessResponse) {
                // Сохраняем результат в отдельной транзакции, чтобы он сохранился после отката основной транзакции
                ThreadScopeRunner.run(() -> ctx.getSession().doInTransaction(() ->
                        // Сохранить в таблице bonus_program_usage результат выполнения запроса (неуспешный)
                        saveErrorResponseEvent(params, responseDto)));
                // Бросаем исключение с переданным кодом и сообщением об ошибке
                throw new BonusSystemException(responseDto.getCode(), responseDto.getMessage());
            }

            // Сохранить в таблице bonus_program_usage результат выполнения запроса (успешный результат)
            saveResponseEvent(params, responseDto);

            /*
             * Сохранить в таблице bonus_program информацию о бонусной программе пользователя,
             * если в ответе от бонусной системы вернулся status со значением PROCESSING или DONE
             * (не сохранять информацию, если вернулся status=NEED_CONFIRM,
             * так как подключение программы требует подтверждения)
             * Уведомить ... о необходимости перечитать список бонусных программ,
             * через NSQ - на случай таймаута ... -> ... или вызова команды из очереди команд
             */
            boolean isProcessing = PROCESSING.equals(responseDto.getRow().getStatus());
            boolean isDone = DONE.equals(responseDto.getRow().getStatus());
            final boolean isSaveNeed = isProcessing || isDone;
            if (isSaveNeed) {
                BonusProgramDto targetBonusProgramDto = getTargetBonusProgramDto(params, responseDto);
                if (isBonusProgramPresent) {
                    bonusProgramDao.update(targetBonusProgramDto);
                } else {
                    bonusProgramDao.create(targetBonusProgramDto);
                }
                messageService.sendBonusProgramChangedNotification(account.getAccountNumber());
            }

            // Вернуть результат выполнения запроса с передачей status и requestId
            /*
             * ... будет возвращать request_id для каждого из статусов: NEED_CONFIRM и PROCESSING.
             * Но в ... нужно возвращать request_id только для статуса NEED_CONFIRM,
             * чтобы приложение использовало его для подтверждения с помощью кода из СМС или email
             */
            boolean isRequestIdNeed = NEED_CONFIRM.equals(responseDto.getRow().getStatus());
            return BonusProgramAddResultDto.builder()
                    .status(responseDto.getRow().getStatus().name())
                    .requestId(isRequestIdNeed ? responseDto.getRow().getRequestId() : null)
                    .build();
        });
    }
    
    /**
     * Вернуть целевое состояние Бонусной программы в зависимости от параметров.
     */
    BonusProgramDto getTargetBonusProgramDto(BonusProgramAddParams params, BonusProgramResponse responseDto) {
        // Создаем DTO с требуемыми значениями полей
        BonusProgramDto.BonusProgramDtoBuilder builder = BonusProgramDto.builder()
                .serviceAccountId(params.getServiceAccountProps().getId())
                .bonusProgramId(params.getBonusProgramSpecDto().getId())
                .status(responseDto.getRow().getStatus());
        /*
         * Нужно принудительно очищать у существующей записи в bonus_program поле bonus_client_id.
         * "... нужно зачищать. У пользователя в один момент должна быть только одна из активностей
         * по каждой бонусной программе".
         */
        boolean isResponseStatusDone = DONE.equals(responseDto.getRow().getStatus());
        builder.bonusClientId(isResponseStatusDone ? responseDto.getRow().getBonusClientId() : null);
        /*
         * Для простоты start_date безусловно перезаписываем при получении ответа PROCESSING/DONE"
         */
        builder.startDate(LocalDateTime.now());
        /*
         * "... нужно зачищать поле stop_date,
         * чтобы информацию о бонусной программе для пользователя передавать в New Cache"
         */
        builder.stopDate(null);
        return builder.build();
    }

    /**
     * Сохранить событие об отправке заявки при разрыве соединения с Бонусной системой по таймауту.
     */
    private void saveTimeoutEvent(BonusProgramAddParams params) {
        BonusProgramUsageDto bonusProgramUsageDto = BonusProgramUsageDto.builder()
                .discriminator("BONUSPROGRAMADDREQUEST")
                .bonusProgramId(params.getBonusProgramSpecDto().getId())
                .serviceAccountId(params.getServiceAccountProps().getId())
                .status(null)
                .login(params.getLogin())
                .loginType(params.getLoginType().name().toLowerCase())
                .usageDate(LocalDateTime.now())
                .requestId(null)
                .bonusClientId(null)
                .wsResult(ERROR_WS_RESULT)
                .wsComment("request timeout")
                .build();
        bonusProgramUsageDbDao.create(bonusProgramUsageDto);
    }

    /**
     * Сохранить событие об отправке заявки на Подключение Бонусной программы.
     */
    private void saveResponseEvent(BonusProgramAddParams params, BonusProgramResponse responseDto) {
        BonusProgramUsageDto bonusProgramUsageDto = BonusProgramUsageDto.builder()
                .discriminator("BONUSPROGRAMADDREQUEST")
                .bonusProgramId(params.getBonusProgramSpecDto().getId())
                .serviceAccountId(params.getServiceAccountProps().getId())
                .status(responseDto.getRow().getStatus())
                .login(params.getLogin())
                .loginType(params.getLoginType().name().toLowerCase())
                .usageDate(LocalDateTime.now())
                .requestId(responseDto.getRow().getRequestId())
                .bonusClientId(responseDto.getRow().getBonusClientId())
                .wsResult(SUCCESS_WS_RESULT)
                .wsComment("hiddenComment")
                .build();
        bonusProgramUsageDbDao.create(bonusProgramUsageDto);
    }

    /**
     * Сохранить событие об отправке заявки на подключение бонусной программы.
     */
    private void saveErrorResponseEvent(BonusProgramAddParams params, BonusProgramResponse responseDto) {
        BonusProgramUsageDto bonusProgramUsageDto = BonusProgramUsageDto.builder()
                .discriminator("BONUSPROGRAMADDREQUEST")
                .bonusProgramId(params.getBonusProgramSpecDto().getId())
                .serviceAccountId(params.getServiceAccountProps().getId())
                .status(null)
                .usageDate(LocalDateTime.now())
                .requestId(null)
                .bonusClientId(null)
                .wsResult(ERROR_WS_RESULT)
                .wsComment(responseDto.getMessage())
                .build();
        bonusProgramUsageDbDao.create(bonusProgramUsageDto);
    }
}

```

</details>

#### Логический дизайн
Цель: Отправить заявку на подключение бонусной программы

Если бонусная программа уже подключена и активна, следует вернуть успешный ответ.

Отправить в бонусную систему запрос на подключение к программе.
Если запрос завершился с ошибкой, то её следует передать пользователю. 
В случае таймаута соединения с бонусной системой вернуть ошибку с кодом 4.
Сохранить в таблице bonus_program_usage результат выполнения запроса (успешный и неуспешный результат).
Сохранить в таблице bonus_program информацию о бонусной программе пользователя, если в ответе от бонусной системы вернулся status со значением PROCESSING или DONE (не сохранять информацию, если вернулся status=NEED_CONFIRM, так как подключение программы требует подтверждения).
Отправить нотификацию об изменении бонусных программ пользователя. 
Вернуть результат выполнения запроса с передачей status и requestId (только для статуса NEED_CONFIRM).


##### Оценка соответствия дизайну
По большому счёту код соответствует логическому дизайну, однако в нём совершается ряд лишних действий, не описанных в дизайне и без которых можно обойтись.
Избавился от лишних операций, убрал вложенные if-ы. Код стал ближе к дизайну.
На итерацию ушло около 2-х часов.

<details>
<summary>Обновлённый код</summary>

```Java
@Service
@Slf4j
@AllArgsConstructor
@Builder(toBuilder = true)
public class BonusProgramService {

    private static int USER_NOT_FOUND = 3;

    public static final long ERROR_WS_RESULT = 0L;
    public static final long SUCCESS_WS_RESULT = 1L;
    public static final int TIMEOUT_WS_RESULT = -2;
    public static final int HOURS_PER_DAY = 24;
    public static final String WS_COMMENT_TIMEOUT_TEXT = "Таймаут при обращении в бонусную систему";
    public static final String SERVICE_BONUS_DISCRIMINATOR_SUBSCRIBER = "SERVICEBONUS";

    private final ExecutionContext ctx;
    private final BonusProgramClient bonusClient;
    private final BonusProgramUsageDbDao bonusProgramUsageDbDao;
    private final BonusProgramDao bonusProgramDao;
    private final MessageService messageService;
    private final ServiceUsageDao serviceUsageDao;
    private final PurchaseDao purchaseDao;
    private final PurchaseHistoryDao purchaseHistoryDao;
    
    public BonusProgramAddResultDto addBonusProgram(BonusProgramAddParams params) {
        return ctx.getSession().doInTransaction(() -> {

            final ServiceAccountProps account = params.getServiceAccountProps();
            Optional<BonusProgramDto> optionalBonusProgramDto = bonusProgramDao
                    .findByBonusProgramIdAndServiceAccountId(
                            params.getBonusProgramSpecDto().getId(), account.getId());
            if (optionalBonusProgramDto.isPresent() && optionalBonusProgramDto.get().isActive()) {
                return BonusProgramAddResultDto.builder()
                        .status(optionalBonusProgramDto.get().getStatus().name())
                        .build();
            }

            // Отправить в бонусную систему (через ...) запрос ...
            BonusProgramResponse responseDto;
            try {
                responseDto = bonusClient.addBonusProgram(BonusProgramRequest.builder()
                        .serviceAccountNumber(account.getAccountNumber())
                        .bonusProgramExternalId(params.getBonusProgramSpecDto().getExternalId())
                        .regionExternalId(params.getLocationDto().getExternalId())
                        .login(params.getLogin())
                        .loginType(params.getLoginType())
                        .serviceType(params.getServiceProviderInBonusProgramDto().getServiceType().name())
                        .build());
            } catch (ConnectionOrReadTimeoutException e) {
                // Сохраняем результат в отдельной транзакции, чтобы он сохранился после отката основной транзакции
                ThreadScopeRunner.run(() -> ctx.getSession().doInTransaction(() -> saveTimeoutEvent(params)));
                log.error(e.getLocalizedMessage());
                // "возвращаем в ... ошибку с кодом 4 и сообщением о таймауте"
                throw new SmtubeException(BONUS_PROGRAM_TIMEOUT_ERROR);
            }

            // В случае получения от бонусной системы ответа с ошибкой вернуть ответ с ошибкой
            boolean isSuccessResponse = responseDto.getCode() == 0;
            if (!isSuccessResponse) {
                // Сохраняем результат в отдельной транзакции, чтобы он сохранился после отката основной транзакции
                ThreadScopeRunner.run(() -> ctx.getSession().doInTransaction(() ->
                        // Сохранить в таблице bonus_program_usage результат выполнения запроса (неуспешный)
                        saveErrorResponseEvent(params, responseDto)));
                // Бросаем исключение с переданным кодом и сообщением об ошибке
                throw new BonusSystemException(responseDto.getCode(), responseDto.getMessage());
            }

            // Сохранить в таблице bonus_program_usage результат выполнения запроса (успешный результат)
            saveResponseEvent(params, responseDto);

            /*
             * Сохранить в таблице bonus_program информацию о бонусной программе пользователя,
             * если в ответе от бонусной системы вернулся status со значением PROCESSING или DONE
             * (не сохранять информацию, если вернулся status=NEED_CONFIRM,
             * так как подключение программы требует подтверждения)
             * Уведомить ... о необходимости перечитать список бонусных программ,
             * через NSQ - на случай таймаута ... -> ... или вызова команды из очереди команд
             */
            boolean isProcessing = PROCESSING.equals(responseDto.getRow().getStatus());
            boolean isDone = DONE.equals(responseDto.getRow().getStatus());
            final boolean isSaveNeed = isProcessing || isDone;
            if (isSaveNeed) {
                BonusProgramDto targetBonusProgramDto = getTargetBonusProgramDto(params, responseDto);
                optionalBonusProgramDto.ifPresentOrElse(bp -> bonusProgramDao.update(targetBonusProgramDto),
                        () -> bonusProgramDao.create(targetBonusProgramDto));
                messageService.sendBonusProgramChangedNotification(account.getAccountNumber());
            }

            // Вернуть результат выполнения запроса с передачей status и requestId
            /*
             * ... будет возвращать request_id для каждого из статусов: NEED_CONFIRM и PROCESSING.
             * Но в ... нужно возвращать request_id только для статуса NEED_CONFIRM,
             * чтобы приложение использовало его для подтверждения с помощью кода из СМС или email
             */
            boolean isRequestIdNeed = NEED_CONFIRM.equals(responseDto.getRow().getStatus());
            return BonusProgramAddResultDto.builder()
                    .status(responseDto.getRow().getStatus().name())
                    .requestId(isRequestIdNeed ? responseDto.getRow().getRequestId() : null)
                    .build();
        });
    }
    
    /**
     * Вернуть целевое состояние Бонусной программы в зависимости от параметров.
     */
    BonusProgramDto getTargetBonusProgramDto(BonusProgramAddParams params, BonusProgramResponse responseDto) {
        // Создаем DTO с требуемыми значениями полей
        return BonusProgramDto.builder()
                .serviceAccountId(params.getServiceAccountProps().getId())
                .bonusProgramId(params.getBonusProgramSpecDto().getId())
                .status(responseDto.getRow().getStatus())
                .startDate(LocalDateTime.now())
                .bonusClientId(responseDto.getRow().getBonusClientId())
                .build();
    }

    /**
     * Сохранить событие об отправке заявки при разрыве соединения с Бонусной системой по таймауту.
     */
    private void saveTimeoutEvent(BonusProgramAddParams params) {
        BonusProgramUsageDto bonusProgramUsageDto = BonusProgramUsageDto.builder()
                .discriminator("BONUSPROGRAMADDREQUEST")
                .bonusProgramId(params.getBonusProgramSpecDto().getId())
                .serviceAccountId(params.getServiceAccountProps().getId())
                .status(null)
                .login(params.getLogin())
                .loginType(params.getLoginType().name().toLowerCase())
                .usageDate(LocalDateTime.now())
                .requestId(null)
                .bonusClientId(null)
                .wsResult(ERROR_WS_RESULT)
                .wsComment("request timeout")
                .build();
        bonusProgramUsageDbDao.create(bonusProgramUsageDto);
    }

    /**
     * Сохранить событие об отправке заявки на Подключение Бонусной программы.
     */
    private void saveResponseEvent(BonusProgramAddParams params, BonusProgramResponse responseDto) {
        BonusProgramUsageDto bonusProgramUsageDto = BonusProgramUsageDto.builder()
                .discriminator("BONUSPROGRAMADDREQUEST")
                .bonusProgramId(params.getBonusProgramSpecDto().getId())
                .serviceAccountId(params.getServiceAccountProps().getId())
                .status(responseDto.getRow().getStatus())
                .login(params.getLogin())
                .loginType(params.getLoginType().name().toLowerCase())
                .usageDate(LocalDateTime.now())
                .requestId(responseDto.getRow().getRequestId())
                .bonusClientId(responseDto.getRow().getBonusClientId())
                .wsResult(SUCCESS_WS_RESULT)
                .wsComment("hiddenComment")
                .build();
        bonusProgramUsageDbDao.create(bonusProgramUsageDto);
    }

    /**
     * Сохранить событие об отправке заявки на подключение бонусной программы.
     */
    private void saveErrorResponseEvent(BonusProgramAddParams params, BonusProgramResponse responseDto) {
        BonusProgramUsageDto bonusProgramUsageDto = BonusProgramUsageDto.builder()
                .discriminator("BONUSPROGRAMADDREQUEST")
                .bonusProgramId(params.getBonusProgramSpecDto().getId())
                .serviceAccountId(params.getServiceAccountProps().getId())
                .status(null)
                .usageDate(LocalDateTime.now())
                .requestId(null)
                .bonusClientId(null)
                .wsResult(ERROR_WS_RESULT)
                .wsComment(responseDto.getMessage())
                .build();
        bonusProgramUsageDbDao.create(bonusProgramUsageDto);
    }
}

```

</details>

## Выводы
Кажется, что задание выполнено плохо. Очень много времени я тратил на то, чтобы найти хороший кусок кода для примеров. 
Почти всегда мне казалось, что большая часть кода примерно соответствует дизайну и сделать какие-либо улучшения будет тяжело.
Возможно не хватает опыта в описании словесного дизайна (нет точного понимания насколько подробным должен быть дизайн, нужно ли опускаться до значений в БД, названий полей или же в рамках дизайна хранилище данных не важно, так же как и конкретные имена), либо код действительно довольно близок к такому дизайну и если его можно улучшить, то не очень сильно.
А скорее всего у меня ещё не хватает опыта, чтобы увидеть плохой дизайн/реализацию и пути по их улучшению.
Порой ловил себя на мысли, что код выглядит как-то не очень, но у меня не получалось описать что конкретно в нём не так и как его качественно улучшить.
Есть ощущение, что большая часть моих правок относится к уровню 2 и никаких качественных изменений я не совершил, при этом я пытался задать больше декларативности и выразительности, но поскольку код уже неплохо выглядит (как мне кажется), улучшить его было сложно.
Дизайн я описывал глядя на код и думая о том как вообще всё должно происходить (на уровне процессов/абстракций),
возможно я местами сильно привязывался к коду и словесное описание дизайна повторяло реализацию.

Из занятия я понял, что нужно стремиться к тому, чтобы код был неотличим от дизайна. 
И хорошую структуру кода легко увидеть, когда ты видишь чёткую структуру дизайна (кажется, что это у меня не очень получалось при выполнении задания).
Чтобы увидеть чёткую структуру дизайна нужно думать о концепциях программы и том что их определяет, нужно быть выше чем код.
