#### Пример 1
У нас есть сервис автопарка, в котором имеются менеджеры, предприятия, автомобили и водители. Автомобили и водители принадлежат какому-либо предприятию (одному). 
Менеджер может быть связан с разными предприятиями и имеет возможность управлять ими(CRUD-операции с различными сущностями предприятия). 
Менеджер логинится и получает токен доступа, который даёт ему право на выполнение CRUD-операций. Однако нам нужно запретить менеджеру взаимодействовать с сущностями предприятий(и самими предприятиями тоже), которые ему не принадлежат.
У каждой сущности есть свой сервисный класс, который предоставляет методы для взаимодействия с сущностью. Почти в каждом методе таких сервисов сначала выполняется проверка на то, что менеджер имеет право на доступ к сущности.
Получаем ситуацию, когда один код неоднократно дублируется в рамках класса.  
Для решения этой проблемы можно выделить функции проверки на принадлежность сущности предприятию в отдельный сервис. В этом сервисе создадим методы для проверки доступа к каждой из сущностей.
Первым дело в сервисах сущностей будем вызывать метод проверки доступа залогиненного менеджера к запрашиваемой сущности из свежесозданного сервиса.   
Это позволит снизить дублирование кода, повысит надёжность системы, так как теперь будет одна точка с проверками доступности сущности и не получится такая ситуация, когда в одном месте логику поправили, а в другом -- забыли.
Плюс должно упроститься тестирование логики проверки доступа, так как она теперь выделена в отдельный сервис. Система становится более модульной и становится ближе к соблюдению SRP.

#### Пример 2
Тот же сервис автопарка, но уже методы получения пути(трека) автомобиля. Контроллер, отвечающий за получение треков несколько отличается от других. 
В основном контроллеры сервиса -- тонкие, приняли запрос и передали в нужный сервисный метод, преобразовали ответ сервиса в дто, с помощью обращения к соответствующему мапперу.
Здесь же накручена дополнительная логика по преобразованию времени к UTC. В коде и БД мы работаем с UTC, но у предприятия может быть другой часовой пояс и мы считаем, что всё время, 
которое присылает нам клиент, имеет часовой пояс текущего предприятия. А значит нам нужно на входе конвертировать время в UTC, а на выходе вернуть его в часовом поясе предприятия.
Сейчас преобразование выполняется в контроллере и для его выполнения мы ищем автомобиль по идентификатору в сервисе(поскольку в запросах на получение трека всегда указывается идентификатор конкретного автомобиля), 
затем достаём оттуда предприятие, которому этот автомобиль принадлежит и уже там смотрим часовой пояс. После этого мы преобразуем входные даты/время в UTC, воспользовавшись методами утилитного класса и уже преобразованные значения передаём их в сервис.  
Очень кажется, что у нас тут образовалась ситуация с нарушением SRP, да и сам контроллер треков, отличается от прочих контроллеров. Также в этот контроллер попадают классы моделей, использующиеся для взаимодействия с БД, о которых ему знать вовсе не обязательно. 
В качестве решения проблемы с контроллером можно использовать паттерн Фасад. В контроллер будем обращаться к фасаду, куда перенесём логику по преобразованию времени и где будет вызываться необходимый сервисный метод.
В итоге получим тонкий контроллер, который лишь обращается к другим сервисам и не содержит в себе особой логики.

#### Итоги
В выводах прошлого занятия писал: "Есть такое ощущение, что мне пока тяжело обозначать чёткие связи между частями системы, выделять их границы, выражать ключевые концепты. Как будто не хватает уверенности или какого-то понимания, что именно делать или как должен выглядеть ключевой концепт.".
Сейчас же я стал чувствовать себя увереннее в этом вопросе, как будто стало приходить понимание того, как вообще стоит разграничивать части системы и что для этого можно делать. Опять возникает такое ощущение, что это занятие складывается с другими и всё сливается в целостную картину, когда ты не просто повторяешь услышанные слова, потому что их сказал кто-то умный, а потому, что понимаешь их смысл и это является частью твоей картины мира.
Это радует, хотя я чувствую, что потенциал для роста тут большой и тут нужно практиковаться и практиковаться.
Вообще в этом задании увидел себя -- боюсь переделывать архитектуру проекта и вносить нелокальные изменения. Но по ходу дела понял, что это важно и в будущем может здорово облегчить жизнь, так что если увижу способы сделать лучше -- буду делать.
Кажется, что приведённые примеры простенькие, но всё же они действительно меняют архитектуру в лучшую сторону. Пусть это будет началом, а стремиться буду к тому, чтобы со временем глаз замечал пути улучшения всё более качественного кода. 