### Неожиданное дефолтное поведение
### 1
Однажды я полагал, что в одном из методов данные выдаются в упорядоченном виде, ну и закладывался на такое поведение. Потом выяснилось, что во время проверок так складывались звёзды и 
данные выдавались по возрастанию id. И лишь почти закончив работу над задачей я увидел, что в очередной выдаче порядок поменялся. Полез глубже в код и обнаружил, что сортировка нигде не гарантируется.
Тут была ошибка с моей стороны. Нужно было внимательнее изучать код.

### 2
Один из наших сервисов получает от другого данные в формате XML. Файл большой и полей в нём много. Часть из них обязательные, часть -- нет. 
Мне нужно было написать новую функцию, которая обрабатывает данные из XML. По ходу дела мне пришлось делать предположения о том какие данные к нам будут приходить всегда, а какие иногда будут отсутствовать.
В ходе тестирования выяснилось, что не все мои предположения были верны и некоторые из всегда ожидаемых мною полей не возвращались. Проект был на лишь тестовой среде и это не доставило проблем.
Но всё могло бы быть и хуже. Кажется, что в этом случае проблема заключалась в недостатке документации. Я нашёл лишь минимум сведений о методе, который возвращает XML. 
По сути там было название метода, адрес, по которому его можно вызвать, и описание основных полей, а по факту их было гораздо больше.

### 3
У нас в коде за работу с соединениями отвечает HikariCP. Мне нужно было использовать рекомендательную блокировку Postgres. Для её взятия я делал запрос в БД. Один из вариантов такой блокировки
привязан к сессии. Я написал довольно наивную реализацию и в ходе тестов выявил, что блокировка пропадает через некоторое время.
Выяснилось, что у соединений в HikariCP есть максимальное время жизни, при достижении которого, соединения пересоздаётся, из-за чего теряются взятые блокировки.
Это поведение было для меня неожиданным, я не знал о пересоздании соединений и если бы не протестировал свой код, то мог бы попасть в неприятную ситуацию.
Проблема возникла из-за моего ошибочного предположения о работе библиотеки. Нужно было читать документацию.

### Продуманный тип результата метода
### 1
Было:
```java
public class DriverDto {
    ...
    private List<Long> vehicleIds;
}
```
Стало:
```java
public class DriverDto {
    ...
    private Set<Long> vehicleIds;
}
```

Заменил List на Set, благодаря чему пользователь структуры данных сразу понимает, что все автомобили уникальны и их порядок не важен. Поэтому нет смысла заниматься сортировкой и удалением дубликатов.

### 2
Было:
```java
 public class PurchaseDto {
    ...
    private String status;
    ...
}
```
```java
 public class PurchaseDto {
    ...
    private Status status;
    ...
}

public enum Status {
    TEMPORARY,
    CONFIRMED,
    CANCELLED,
    EXCHANGED
}
```

Заменил Строку на Перечисление. Получаем более наглядный код (теперь без похода в документацию понятно, а какие вообще есть статусы),
также снижается вероятность ошибок, так как пользователь не может указать несуществующий статус.

### 3
Было:
```java
...
List<List<String>> qres = ctx.getSession().executeQuery(
                    "SELECT ID FROM TERMINAL WHERE TOKEN = :TOKEN ",
                    set(new StringParameterBinding("TOKEN", token)
                    ));
...
```
Стало:
```java
...
List<Long> terminalIds = ctx.getSession().executeQueryForList(
        rs -> rs.getLong("ID"),
        "SELECT ID FROM TERMINAL WHERE TOKEN = :TOKEN ",
        set(new StringParameterBinding("TOKEN", token)
));
...
```
Есть метод, который возвращает из БД список терминалов с определённым токеном. В изначальной версии мы получали Список со Списками Строк.
Довольно странный ответ. В первом списке были перечислены имена полей, а в последующих -- их значения. Изменил имя и тип результата, теперь мы получаем один список чисел.
Это должно значительно повысить читаемость кода и сузить количество способов, которым можно обработать результат.


#### Вывод
Нужно внимательнее изучать то, что ты используешь в проекте, иначе можно столкнуться с неожиданными проблемами.
Также следует использовать продуманные типы данных, желательно сужать диапазон действий, которые можно совершить с результатами твоих функций.
Это сделает код более предсказуемым и понятным, что благотворно скажется на частоте ошибок. Помимо этого не стоит забывать о спецификации.
Там нужно указывать важные для системы моменты и опускать те вещи, которые являются для неё незначительными.