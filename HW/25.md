#### Пример 1
Есть метод, задача которого выдать список автомобилей, доступных авторизованному менеджеру.

**Изначальная версия**
```java
class Controller {
    public List<VehicleDto> findAllForCurrentManager() {
        Manager manager = securityUtils.getCurrentManager();

        if (manager == null) {
            return Collections.emptyList();
        }

        List<VehicleDto> vehicles = vehicleService.findByManager(manager).stream()
                .map(toVehicleDtoConverter::convert)
                .toList();

        log.info("Found {} vehicles for {}", vehicles.size(), manager.getUsername());
        return vehicles;
    }
}

class Service {
    public List<Vehicle> findByManager(Manager manager) {
        log.info("get vehicles from DB for manager: {}", manager.getUsername());
        return vehicleRepository.findByEnterprises(manager.getEnterprises());
    }
}

class Repository {
    public List<Vehicle> findByEnterprises(Collection<Enterprise> enterprises) {
        if (enterprises == null || enterprises.isEmpty()) {
            return Collections.emptyList();
        }
        TypedQuery<Vehicle> query = entityManager.createQuery(
                "SELECT v FROM Vehicle v WHERE v.enterprise IN :enterprises", Vehicle.class);
        query.setHint("jakarta.persistence.fetchgraph", entityManager.getEntityGraph("Vehicle.detail"));
        query.setParameter("enterprises", enterprises);
        return query.getResultList();
    }
}
```

При вызове метода в логах можно было увидеть следующие SQL-запросы:
```
Hibernate: 
    select
        m1_0.id,
        m1_0.password,
        m1_0.username 
    from
        Manager m1_0 
    where
        m1_0.username=?
Hibernate: 
    select
        e1_0.manager_id,
        e1_1.id,
        e1_1.city,
        e1_1.name,
        e1_1.time_zone 
    from
        manager_enterprise e1_0 
    join
        Enterprise e1_1 
            on e1_1.id=e1_0.enterprise_id 
    where
        e1_0.manager_id=?
12:44:02.377 [http-nio-8080-exec-9] INFO  r.lessons.my.service.VehicleService - get vehicles from DB for manager: manager1
Hibernate: 
    select
        v1_0.id,
        v1_0.active_driver_id,
        v1_0.color,
        v1_0.enterprise_id,
        e1_0.id,
        e1_0.city,
        e1_0.name,
        e1_0.time_zone,
        v1_0.license_plate_number,
        v1_0.mileage,
        v1_0.vehicle_model_id,
        m1_0.id,
        m1_0.brand_name,
        m1_0.fuel_tank_capacity,
        m1_0.load_capacity,
        m1_0.model_name,
        m1_0.seats_number,
        m1_0.type,
        v1_0.production_year,
        v1_0.purchase_date_time,
        v1_0.purchase_price 
    from
        Vehicle v1_0 
    join
        Enterprise e1_0 
            on e1_0.id=v1_0.enterprise_id 
    join
        vehicle_model m1_0 
            on m1_0.id=v1_0.vehicle_model_id 
    where
        v1_0.enterprise_id in (?, ?, ?)
```

В среднем метод отрабатывает за 240 мс.

**Новая версия с прямым запросом к БД**
```java
class Controller {
    @GetMapping("/sql")
    public List<VehicleDto> findAllForCurrentManagerSql() {
        String managerName = SecurityContextHolder.getContext().getAuthentication().getName();

        List<VehicleDto> vehicles = vehicleService.findByManagerName(managerName);

        log.info("Found {} vehicles for {}", vehicles.size(), managerName);
        return vehicles;
    }
}

class Service {
    public List<VehicleDto> findByManagerName(String name) {
        log.info("get vehicles from DB for manager: {}", name);
        return vehicleRepository.findByManagerName(name);
    }
}

class Repository {
    public List<VehicleDto> findByManagerName(String name) {
        String query = """
                select *
                from vehicle
                where enterprise_id in
                    (select me.enterprise_id
                     from manager_enterprise me
                        join manager m on m.id = me.manager_id
                     where m.username = ?)
                """;

        return jdbcTemplate.query(query, new BeanPropertyRowMapper<>(VehicleDto.class), name);
    }
}
```

Для краткости заменил список всех полей в запросе на звёздочку. Новый метод отрабатывает в среднем за 120 мс.

Получилось двукратное ускорение.  

Что нам тут помогло:  
Количество обращений к БД сократилось с трёх до одного. Раньше мы получали имя менеджера из контекста безопасности, искали менеджера и связанные с ним предприятия в БД
и только потом выполняли поиск автомобилей по списку предприятий, которые принадлежат менеджеру. Теперь мы получаем имя из контекста и сразу идём получать список автомобилей с помощью самописного запроса.

Есть ощущение, что разрыв в скорости мог быть гораздо больше. В изначальном варианте используется entity graph, который позволяет жадно подгрузить нужные сущности в рамках одного запроса.
То есть видны попытки обуздать orm и заставить её совершать меньше действий. Без этого, мы скорее всего столкнулись бы с N+1 и время работы изначального метода было бы гораздо больше. 

#### Пример 2
Есть метод, возвращающий список географических точек, которые посетил автомобиль в указанный промежуток времени. 

**Изначальная версия**
```java
@Entity
@Getter
@Setter
@Builder
@NoArgsConstructor
@AllArgsConstructor
@Table(name = "geo_point")
public class GeoPoint {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "position", columnDefinition = "geometry(Point, 4326)", nullable = false)
    private Point position;

    @Column(name = "visited_at", nullable = false)
    private LocalDateTime visitedAt;

    @ManyToOne
    @JoinColumn(name = "vehicle_id")
    private Vehicle vehicle;

    @ManyToOne
    @JoinColumn(name = "trip_id")
    private Trip trip;
}

@Entity
@Getter
@Setter
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class Trip {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "start_date")
    private LocalDateTime startDate;

    @Column(name = "end_date")
    private LocalDateTime endDate;

    @Column(name = "mileage")
    private int mileageKm;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "vehicle_id", nullable = false)
    private Vehicle vehicle;

    @OneToOne(cascade = {CascadeType.PERSIST, CascadeType.MERGE})
    @JoinColumn(name = "start_geo_point_id")
    private GeoPoint startPoint;

    @OneToOne(cascade = {CascadeType.PERSIST, CascadeType.MERGE})
    @JoinColumn(name = "end_geo_point_id")
    private GeoPoint endPoint;
}

class Repository {
    public List<GeoPoint> getGeoPointsByVehicleIdAndTimeRange(long vehicleId, LocalDateTime from, LocalDateTime to) {
        String query = """
                SELECT g
                FROM GeoPoint g
                WHERE g.vehicle.id = :vehicleId
                    AND g.visitedAt BETWEEN :from and :to
                ORDER BY g.visitedAt
                """;
        return entityManager.createQuery(query, GeoPoint.class)
                .setParameter("vehicleId", vehicleId)
                .setParameter("from", from)
                .setParameter("to", to)
                .getResultList();
    }
}
```

При вызове метода, в логах можно было заметить 2 вида SQL-запросов:

```
Hibernate: 
    select
        gp1_0.id,
        gp1_0.position,
        gp1_0.trip_id,
        gp1_0.vehicle_id,
        gp1_0.visited_at 
    from
        geo_point gp1_0 
    where
        gp1_0.vehicle_id=? 
        and gp1_0.visited_at between ? and ? 
    order by
        gp1_0.visited_at
Hibernate: 
    select
        t1_0.id,
        t1_0.end_date,
        ep1_0.id,
        ep1_0.position,
        t2_0.id,
        t2_0.end_date,
        t2_0.end_geo_point_id,
        t2_0.mileage,
        t2_0.start_date,
        sp1_0.id,
        sp1_0.position,
        sp1_0.trip_id,
        v1_0.id,
        ad1_0.id,
        ad1_0.enterprise_id,
        e1_0.id,
        e1_0.city,
        e1_0.name,
        e1_0.time_zone,
        ad1_0.name,
        ad1_0.salary,
        v1_0.color,
        v1_0.enterprise_id,
        e2_0.id,
        e2_0.city,
        e2_0.name,
        e2_0.time_zone,
        v1_0.license_plate_number,
        v1_0.mileage,
        v1_0.vehicle_model_id,
        m1_0.id,
        m1_0.brand_name,
        m1_0.fuel_tank_capacity,
        m1_0.load_capacity,
        m1_0.model_name,
        m1_0.seats_number,
        m1_0.type,
        v1_0.production_year,
        v1_0.purchase_date_time,
        v1_0.purchase_price,
        sp1_0.visited_at,
        t2_0.vehicle_id,
        v3_0.id,
        ad2_0.id,
        ad2_0.enterprise_id,
        e3_0.id,
        e3_0.city,
        e3_0.name,
        e3_0.time_zone,
        ad2_0.name,
        ad2_0.salary,
        v3_0.color,
        v3_0.enterprise_id,
        e4_0.id,
        e4_0.city,
        e4_0.name,
        e4_0.time_zone,
        v3_0.license_plate_number,
        v3_0.mileage,
        v3_0.vehicle_model_id,
        m2_0.id,
        m2_0.brand_name,
        m2_0.fuel_tank_capacity,
        m2_0.load_capacity,
        m2_0.model_name,
        m2_0.seats_number,
        m2_0.type,
        v3_0.production_year,
        v3_0.purchase_date_time,
        v3_0.purchase_price,
        ep1_0.visited_at,
        t1_0.mileage,
        t1_0.start_date,
        sp2_0.id,
        sp2_0.position,
        t4_0.id,
        t4_0.end_date,
        ep3_0.id,
        ep3_0.position,
        ep3_0.trip_id,
        v4_0.id,
        ad3_0.id,
        ad3_0.enterprise_id,
        e5_0.id,
        e5_0.city,
        e5_0.name,
        e5_0.time_zone,
        ad3_0.name,
        ad3_0.salary,
        v4_0.color,
        v4_0.enterprise_id,
        e6_0.id,
        e6_0.city,
        e6_0.name,
        e6_0.time_zone,
        v4_0.license_plate_number,
        v4_0.mileage,
        v4_0.vehicle_model_id,
        m3_0.id,
        m3_0.brand_name,
        m3_0.fuel_tank_capacity,
        m3_0.load_capacity,
        m3_0.model_name,
        m3_0.seats_number,
        m3_0.type,
        v4_0.production_year,
        v4_0.purchase_date_time,
        v4_0.purchase_price,
        ep3_0.visited_at,
        t4_0.mileage,
        t4_0.start_date,
        t4_0.start_geo_point_id,
        t4_0.vehicle_id,
        v6_0.id,
        ad4_0.id,
        ad4_0.enterprise_id,
        e7_0.id,
        e7_0.city,
        e7_0.name,
        e7_0.time_zone,
        ad4_0.name,
        ad4_0.salary,
        v6_0.color,
        v6_0.enterprise_id,
        e8_0.id,
        e8_0.city,
        e8_0.name,
        e8_0.time_zone,
        v6_0.license_plate_number,
        v6_0.mileage,
        v6_0.vehicle_model_id,
        m4_0.id,
        m4_0.brand_name,
        m4_0.fuel_tank_capacity,
        m4_0.load_capacity,
        m4_0.model_name,
        m4_0.seats_number,
        m4_0.type,
        v6_0.production_year,
        v6_0.purchase_date_time,
        v6_0.purchase_price,
        sp2_0.visited_at,
        t1_0.vehicle_id 
    from
        Trip t1_0 
    left join
        geo_point ep1_0 
            on ep1_0.id=t1_0.end_geo_point_id 
    left join
        Trip t2_0 
            on t2_0.id=ep1_0.trip_id 
    left join
        geo_point sp1_0 
            on sp1_0.id=t2_0.start_geo_point_id 
    left join
        Vehicle v1_0 
            on v1_0.id=sp1_0.vehicle_id 
    left join
        Driver ad1_0 
            on ad1_0.id=v1_0.active_driver_id 
    left join
        Enterprise e1_0 
            on e1_0.id=ad1_0.enterprise_id 
    left join
        Enterprise e2_0 
            on e2_0.id=v1_0.enterprise_id 
    left join
        vehicle_model m1_0 
            on m1_0.id=v1_0.vehicle_model_id 
    left join
        Vehicle v3_0 
            on v3_0.id=ep1_0.vehicle_id 
    left join
        Driver ad2_0 
            on ad2_0.id=v3_0.active_driver_id 
    left join
        Enterprise e3_0 
            on e3_0.id=ad2_0.enterprise_id 
    left join
        Enterprise e4_0 
            on e4_0.id=v3_0.enterprise_id 
    left join
        vehicle_model m2_0 
            on m2_0.id=v3_0.vehicle_model_id 
    left join
        geo_point sp2_0 
            on sp2_0.id=t1_0.start_geo_point_id 
    left join
        Trip t4_0 
            on t4_0.id=sp2_0.trip_id 
    left join
        geo_point ep3_0 
            on ep3_0.id=t4_0.end_geo_point_id 
    left join
        Vehicle v4_0 
            on v4_0.id=ep3_0.vehicle_id 
    left join
        Driver ad3_0 
            on ad3_0.id=v4_0.active_driver_id 
    left join
        Enterprise e5_0 
            on e5_0.id=ad3_0.enterprise_id 
    left join
        Enterprise e6_0 
            on e6_0.id=v4_0.enterprise_id 
    left join
        vehicle_model m3_0 
            on m3_0.id=v4_0.vehicle_model_id 
    left join
        Vehicle v6_0 
            on v6_0.id=sp2_0.vehicle_id 
    left join
        Driver ad4_0 
            on ad4_0.id=v6_0.active_driver_id 
    left join
        Enterprise e7_0 
            on e7_0.id=ad4_0.enterprise_id 
    left join
        Enterprise e8_0 
            on e8_0.id=v6_0.enterprise_id 
    left join
        vehicle_model m4_0 
            on m4_0.id=v6_0.vehicle_model_id 
    where
        t1_0.id=?
```

Последний запрос выполняется столько раз, сколько автомобиль совершил поездок в указанный промежуток времени. Убрал дубликаты запроса из примера лога, чтобы не занимать слишком много места. 

Метод отрабатывает где-то за 600 мс. В БД было 4 поездки и 1642 точки для указанного промежутка времени. В ответе мы получили 1642 точки.

**Новая версия с прямым запросом к БД**
```java
class Repository {
    public List<GeoPointDto> getGeoPointsByVehicleIdAndTimeRangeSql(long vehicleId, LocalDateTime from, LocalDateTime to) {
        String query = """
                SELECT *
                FROM geo_point
                WHERE vehicle_id = ?
                    AND visited_at BETWEEN ? and ?
                ORDER BY visited_at
                """;
        return jdbcTemplate.query(query, new BeanPropertyRowMapper<>(GeoPointDto.class), vehicleId, from, to);
    }
}
```

Новая версия работает где-то 200 мс и отправляет в БД лишь 1 запрос, который прописан в методе репозитория.

Получили трёхкратную разницу. Кажется, что чем больше будет поездок у автомобиля в определённый период времени, тем сильнее будет становиться разница в скорости работы старого и нового подхода.
Я не ожидал, что hibernate будет тащить так много лишних данных. В изначальном варианте с orm было очень много джоинов. 
Кажется это связано с тем, что сущности тесно связаны друг с другом и такая длинная цепочка джоинов является попыткой распутать клубок связей. 
Однако данные, которые достаются с помощью такого объёмного запроса нам не нужны и эти длинные запросы избыточны.

#### Пример 3
Есть метод, который возвращает информацию о водителе по его идентификатору.

**Изначальная версия**
```java
@Entity
@Getter
@Setter
@Builder
@NoArgsConstructor
@AllArgsConstructor
@NamedEntityGraph(
        name = "Driver.detail",
        attributeNodes = {
                @NamedAttributeNode("enterprise"),
                @NamedAttributeNode("vehicles")
        }
)
public class Driver {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String name;

    @Column(name = "salary")
    private Double salaryRub;

    @ManyToOne
    @JoinColumn(name = "enterprise_id", nullable = false)
    private Enterprise enterprise;

    @OneToOne(mappedBy = "activeDriver")
    private Vehicle currentVehicle;

    @Builder.Default
    @ManyToMany(cascade = {CascadeType.MERGE})
    @JoinTable(name="driver_vehicle",
            joinColumns=  @JoinColumn(name="driver_id", referencedColumnName="id"),
            inverseJoinColumns= @JoinColumn(name="vehicle_id", referencedColumnName="id") )
    private Set<Vehicle> vehicles = new HashSet<>();
}

class Repository {
    public Optional<Driver> findById(Long id) {
        Map<String, Object> hints = new HashMap<>();
        hints.put("jakarta.persistence.fetchgraph", entityManager.getEntityGraph("Driver.detail"));

        return Optional.ofNullable(entityManager.find(Driver.class, id, hints));
    }
}
```
 
В логах видны следующие sql-запросы:

```
Hibernate: 
    select
        d1_0.id,
        d1_0.enterprise_id,
        e1_0.id,
        e1_0.city,
        e1_0.name,
        e1_0.time_zone,
        d1_0.name,
        d1_0.salary,
        v1_0.driver_id,
        v1_1.id,
        v1_1.active_driver_id,
        v1_1.color,
        v1_1.enterprise_id,
        v1_1.license_plate_number,
        v1_1.mileage,
        v1_1.vehicle_model_id,
        v1_1.production_year,
        v1_1.purchase_date_time,
        v1_1.purchase_price 
    from
        Driver d1_0 
    join
        Enterprise e1_0 
            on e1_0.id=d1_0.enterprise_id 
    left join
        driver_vehicle v1_0 
            on d1_0.id=v1_0.driver_id 
    left join
        Vehicle v1_1 
            on v1_1.id=v1_0.vehicle_id 
    where
        d1_0.id=?
Hibernate: 
    select
        v1_0.id,
        ad1_0.id,
        ad1_0.enterprise_id,
        e1_0.id,
        e1_0.city,
        e1_0.name,
        e1_0.time_zone,
        ad1_0.name,
        ad1_0.salary,
        v1_0.color,
        v1_0.enterprise_id,
        e2_0.id,
        e2_0.city,
        e2_0.name,
        e2_0.time_zone,
        v1_0.license_plate_number,
        v1_0.mileage,
        v1_0.vehicle_model_id,
        m1_0.id,
        m1_0.brand_name,
        m1_0.fuel_tank_capacity,
        m1_0.load_capacity,
        m1_0.model_name,
        m1_0.seats_number,
        m1_0.type,
        v1_0.production_year,
        v1_0.purchase_date_time,
        v1_0.purchase_price 
    from
        Vehicle v1_0 
    left join
        Driver ad1_0 
            on ad1_0.id=v1_0.active_driver_id 
    left join
        Enterprise e1_0 
            on e1_0.id=ad1_0.enterprise_id 
    join
        Enterprise e2_0 
            on e2_0.id=v1_0.enterprise_id 
    join
        vehicle_model m1_0 
            on m1_0.id=v1_0.vehicle_model_id 
    where
        v1_0.active_driver_id=?
```

Весь метод отрабатывает за 160 ms.

**Новая версия с прямым запросом к БД**
```java
class Repository {
    public Optional<DriverDto> findByIdSql(Long id) {
        String query = """
                SELECT d.id,
                    d."name",
                    d.salary,
                    d.enterprise_id,
                    av.id current_vehicle_id,
                    ARRAY_AGG(dv.vehicle_id) vehicle_ids
                FROM driver d
                    left join vehicle av on av.active_driver_id = d.id
                    left join driver_vehicle dv on dv.driver_id=d.id
                WHERE d.id = ?
                group by d.id, d."name", d.salary, d.enterprise_id, av.id
                """;

        return Optional.ofNullable(jdbcTemplate.queryForObject(query, new DriverRowMapper(), id));
    }
}
```

Новый метод отрабатывает где-то за 100 мс.
Получаем разницу в полтора раза и 1, но более сложный sql-запрос. 

Было несколько неожиданно увидеть как hibernate получает список связанных автомобилей.
Я думал, что будут использоваться подзапросы, но для заполнения списка применяется лишь один запрос, который достаёт и другие данные.
А второй запрос от hibernate берёт данные для активного автомобиля, который связан с водителем отношением 1 к 1.
Изначально мне казалось, что hibernate будет отрабатывать гораздо хуже и делать больше запросов, но думаю, что тут немалую роль сыграло использование entity graph, 
который заставляет получить указанные данные в рамках одного запроса.


#### Вывод
Кажется, что при работе с кодом и БД стоит не забывать о том, как там всё устроено под капотом и учитывать orm, которая может выполнять много лишних операций. 
Для особо важных/частых запросов нужно проверять количество и вид запросов, которые генерируются автоматически. Где-то лучше писать запросы вручную, а где-то можно обойтись средствами orm.
По крайней мере в JPA и hibernate есть ряд инструментов, которые позволяют влиять на генерируемые запросы. Благодаря чему можно получать адекватные запросы при минимальном написании шаблонного кода(мапперы и прочее).