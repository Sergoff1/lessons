##### Класс слишком большой (нарушение SRP), или в программе создаётся слишком много его инстансов
<details>
<summary>Код</summary>

```java
package net.some.package;

//a lot of imports

/**
 * Парсер программы передач.
 */
@Slf4j
@Component
public class ImportEpg {

    @Autowired
    private HttpClientFacade epgHttpClientForData;

    @Autowired
    private HttpClientFacade epgHttpClientForPictures;

    private final Function<ExecutionContext, ContentService> contentServiceFactory = ContentService::new;

    private final Function<Session, EpgDao> epgDaoFactory = EpgDao::new;

    private int removeCount;
    private int updateCount;
    private int addCount;
    private long timeDbInsert;
    private long timeDbUpdate;
    private long timeDbSelect;
    private long timeLoadXml;
    private long timeLoadPic;
    private long timeFull;

    private final SimpleDateFormat FORMAT = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
    private final SimpleDateFormat FORMAT_EVENT = new SimpleDateFormat("dd.MM.yyyy HH:mm:ss");
    private final SimpleDateFormat FORMAT_DATE = new SimpleDateFormat("yyyy-MM-dd");

    private static final String IMAGE_FILENAME_PREFIX = "imp_img";
    private static final String BANNER_FILENAME_PREFIX = "imp_ban";

    /**
     * чтобы не читать по 100 раз одно и тоже, кешируем
     */
    private final CachedMap<String, Long> countryCache = new CachedMap<>();
    private final CachedMap<String, Long> programGenreCache = new CachedMap<>();
    private final CachedMap<String, Long> programContentGenreCache = new CachedMap<>();
    private final CachedMap<String, Long> categoryCache = new CachedMap<>();
    private final CachedMap<String, Long> tagCache = new CachedMap<>();
    private final CachedMap<String, Long> accessLevelCache = new CachedMap<>();
    @Getter
    private final Map<String, String> imagesLoadedCache = new HashMap<>();

    private final List<Channel> channelCache = new Vector<>();

    private Map<String, String> currentParams = new HashMap<>();
    private final ConverterContext converterContext = null;

    // для оптимизации я вынесу некоторые statemts сюда
    private NamedParameterPreparedStatement findChannels;
    private NamedParameterPreparedStatement getExternalIdsOfPublishedEpg;
    private NamedParameterPreparedStatement mergeChannelImportLog;
    private NamedParameterPreparedStatement insertProgram;
    private NamedParameterPreparedStatement updateProgram;
    private NamedParameterPreparedStatement insertEpg;
    private NamedParameterPreparedStatement updateEpg;
    private NamedParameterPreparedStatement insertTaskImportLogo;
    private NamedParameterPreparedStatement getProgramForUpdate;
    private NamedParameterPreparedStatement mergeTaskImportLogo;

    private Long minAccessLevel;


    private static final String EPG_SIMPLE_TYPE = "EPG";
    private static final String EPG_BARKER_TYPE = "BARKEREPG";
    private static final String EPG_ADVERTISING_TYPE = "ADVERTISINGEPG";

    private static final String EPG_SIMPLE_DISCRIMINATOR = "EPG";
    private static final String EPG_BARKER_DISCRIMINATOR = "BARKEREPG";
    private static final String EPG_ADVERTISING_DISCRIMINATOR = "ADVERTISINGEPG";

    private static final String PROGRAM_SIMPLE_DISCRIMINATOR = "PROGRAM";
    private static final String PROGRAM_BARKER_DISCRIMINATOR = "BARKERPROGRAM";
    private static final String PROGRAM_ADVERTISING_DISCRIMINATOR = "ADVERTISING";

    private static String getEpgDiscrByType(String epgType) {
        if (EPG_SIMPLE_TYPE.equals(epgType)) {
            return EPG_SIMPLE_DISCRIMINATOR;
        } else if (EPG_BARKER_TYPE.equals(epgType)) {
            return EPG_BARKER_DISCRIMINATOR;
        } else if (EPG_ADVERTISING_TYPE.equals(epgType)) {
            return EPG_ADVERTISING_DISCRIMINATOR;
        } else {
            return EPG_SIMPLE_DISCRIMINATOR;
        }
    }

    private static String getProgramDiscrByType(String epgType) {
        if (EPG_SIMPLE_TYPE.equals(epgType)) {
            return PROGRAM_SIMPLE_DISCRIMINATOR;
        } else if (EPG_BARKER_TYPE.equals(epgType)) {
            return PROGRAM_BARKER_DISCRIMINATOR;
        } else if (EPG_ADVERTISING_TYPE.equals(epgType)) {
            return PROGRAM_ADVERTISING_DISCRIMINATOR;
        } else {
            return PROGRAM_SIMPLE_DISCRIMINATOR;
        }
    }

    private String prefix = "";

    private static final String GET_SCHEDULE_FOR_PARAMS_WHERE_PART =
            // language=SQL
            " WHERE S.SERVICE_SPEC_ID = :SS\n" +
            "   AND S.IS_PUBLISHED = 1 \n" +
            "   AND S.LOCATION_ID = :LOC \n" +
            "   AND S.SECTION = :SECTION \n" +
            "   AND (:PROCESS_EPG_FROM_DATE IS NULL OR S.START_DATE >= :PROCESS_EPG_FROM_DATE)  \n" +
            "   AND (:PROCESS_EPG_TO_DATE IS NULL OR S.START_DATE <= :PROCESS_EPG_TO_DATE)  \n" +
            "   AND S.DISCRIMINATOR = :DISCRIMINATOR \n";

    /**
     * Добавить в таблицу (обычно DICTIONARY) запись с именем и внешним ключом.
     * table и discriminator будут использованы в ВЕРХНЕМ РЕГИСТРЕ.
     * name и externalId будут Капитализированы.
     */
    private static long addNameAndExternalIdToTableWithSortOrder(Session session, String table, String discriminator,
                                                                 String name, String externalId) throws Exception {

        table = table.toUpperCase();
        discriminator = discriminator.toUpperCase();
        name = StringUtils.capitalize(name);
        externalId = StringUtils.capitalize(externalId);

        long id = CommonDAO.generateId(session, discriminator);

        String sql = String.format("INSERT INTO %1$s (ID, DISCRIMINATOR, NAME, EXTERNALID, SORT_ORDER) " +
                                   "SELECT :ID, :D, :NAME, :EXTERNALID, COALESCE(MAX(SORT_ORDER),0) + 1 " +
                                   "FROM %1$s WHERE DISCRIMINATOR = :D", table);
        session.executeUpdate(sql,
                bind("ID", id),
                bind("D", discriminator),
                bind("NAME", name),
                bind("EXTERNALID", externalId));
        return id;
    }

    private void precompileStmpts1(ExecutionContext ctx) throws SQLException {
        // проверка даты и наличия канала
        findChannels = ctx.getSession().getPreparedStatement(
                //language=SQL
                "SELECT X.ID,\n" +
                "       X.EXTERNALID,\n" +
                "       X.LOCATION_ID,\n" +
                "       COALESCE(IL.LAST_UPD, TO_DATE('1970', 'YYYY')),\n" +
                "       X.NAME,\n" +
                "       X.IS_PUBLISHED,\n" +
                "       X.MRF\n" +
                "  FROM (SELECT SS.ID, CU.EXTERNALID, CU.LOCATION_ID, SS.NAME, SS.IS_PUBLISHED, SS.MRF\n" +
                "          FROM SERVICE_SPEC SS\n" +
                "          JOIN CHANNEL_URL_OVERRIDE CU\n" +
                "            ON CU.CHANNEL_ID = SS.ID\n" +
                "         WHERE SS.DISCRIMINATOR = 'BROADCASTCHANNEL'\n" +
                "           AND CU.EXTERNALID = :EID\n" +
                "        UNION ALL\n" +
                "        SELECT SS.ID, SS.EXTERNALID, -1,             SS.NAME, SS.IS_PUBLISHED, SS.MRF\n" +
                "          FROM SERVICE_SPEC SS\n" +
                "         WHERE SS.DISCRIMINATOR = 'BROADCASTCHANNEL'\n" +
                "           AND SS.EXTERNALID = :EID\n" +
                "        UNION ALL \n" +
                "        SELECT SS.ID, SS.EXTERNALID, -2,             SS.NAME, SS.IS_PUBLISHED, SS.MRF\n" +
                "          FROM SERVICE_SPEC SS\n" +
                "         WHERE SS.DISCRIMINATOR = 'BROADCASTCHANNEL'\n" +
                "           AND SS.OVERRIDE_NAME = :EID) X\n" +
                "  LEFT JOIN CHANNEL_IMPORT_LOG IL\n" +
                "    ON IL.CHANNEL_EXT = X.EXTERNALID\n" +
                "   AND IL.SECTION = :SECTION\n"
        );
    }

    private void precompileStmpts2(ExecutionContext ctx) throws SQLException {
        mergeChannelImportLog = ctx.getSession().getPreparedStatement(
                // language=SQL
                "MERGE INTO CHANNEL_IMPORT_LOG DEST\n" +
                "USING (SELECT :LAST_UPD LAST_UPD, :SECTION SECTION, :CHANNEL_EXT CHANNEL_EXT FROM DUAL) S\n" +
                "ON (DEST.SECTION = S.SECTION AND DEST.CHANNEL_EXT = S.CHANNEL_EXT)\n" +
                "WHEN MATCHED THEN\n" +
                "  UPDATE SET DEST.LAST_UPD = S.LAST_UPD\n" +
                "WHEN NOT MATCHED THEN\n" +
                "  INSERT (DEST.LAST_UPD, DEST.SECTION, DEST.CHANNEL_EXT)\n" +
                "  VALUES (S.LAST_UPD, S.SECTION, S.CHANNEL_EXT)");

        getExternalIdsOfPublishedEpg = ctx.getSession().getPreparedStatement(
                // language=SQL
                "SELECT S.EXTERNALID FROM SCHEDULE S \n" +
                GET_SCHEDULE_FOR_PARAMS_WHERE_PART
        );

        insertProgram = ctx.getSession().getPreparedStatement(
                // language=SQL
                "INSERT INTO CONTENT\n" +
                "  (ID,\n" +
                "   DISCRIMINATOR,\n" +
                "   NAME,\n" +
                "   PPV_EXTERNALID,\n" +
                "   TSTV_ALLOWED,\n" +
                "   PL_ALLOWED,\n" +
                "   EXTERNALID,\n" +
                "   ORIGINALNAME,\n" +
                "   COUNTRY_ID,\n" +
                "   DESCRIPTION,\n" +
                "   DESCRIPTION_LONG,\n" +
                "   YEAR,\n" +
                "   LOGO,\n" +
                "   BANNER,\n" +
                "   LINKED_DISCRIMINATOR,\n" +
                "   PARENT_ID,\n" +
                "   ACTORS," +
                "   DIRECTOR," +
                "   SCREENPLAY," +
                "   OPERATOR," +
                "   COMPOSER," +
                "   PRODUCER," +
                "   LEADING," +
                "   IS_PUBLISHED," +
                "   BUNDLE_NAME," +
                "   SERIES_NUMBER," +
                "   SEASON_NUMBER," +
                "   SEASON_SERIES_NUMBER," +
                "   EPISODENAME," +
                "   GENRE_ID," +
                "   CONTENT_GENRE_ID," +
                "   GENRE_LIST," +
                "   CATEGORY_LIST," +
                "   CATEGORY_ABCDE_ID," +
                "   IS_CHILD," +
                "   IS_RECOMMENDED," +
                "   ACCESS_LEVEL_ID," +
                "   CHNL_ID," +
                "   SHORT_TYPE," +
                "   SHORT_DESC," +
                "   ORIG_NAME," +
                "   IS_LIVE," +
                "   IS_PREMIERE," +
                "   SEASON_NUM," +
                "   IMDB_ID," +
                "   IMDB_RATING," +
                "   HD_IMAGE," +
                "   ORIGINAL_ID," +
                "   KINOPOISK_ID," +
                "   KINOPOISK_RATING," +
                "   COMPANY)\n" +
                "VALUES\n" +
                "  (CREATEOBJECT(:DISCRIMINATOR),\n" +
                "   :DISCRIMINATOR,\n" +
                "   :NAME,\n" +
                "   :PPV_EXTERNALID,\n" +
                "   :TSTV_ALLOWED,\n" +
                "   :PL_ALLOWED,\n" +
                "   :EXTERNALID,\n" +
                "   :ORIGINALNAME,\n" +
                "   :COUNTRY,\n" +
                "   :DESCRIPTION,\n" +
                "   :DESCRIPTION_LONG,\n" +
                "   :YEAR,\n" +
                "   :LOGO,\n" +
                "   :BANNER,\n" +
                "   :LINKED_DISCRIMINATOR,\n" +
                "   :LINKED_ID,\n" +
                "   :ACTORS," +
                "   :DIRECTOR," +
                "   :SCREENPLAY," +
                "   :OPERATOR," +
                "   :COMPOSER," +
                "   :PRODUCER," +
                "   :LEADING," +
                "   :IS_PUBLISHED," +
                "   :BUNDLE_NAME," +
                "   :SERIES_NUMBER," +
                "   :SEASON_NUMBER," +
                "   :SEASON_SERIES_NUMBER," +
                "   :EPISODENAME," +
                "   :GENRE_ID," +
                "   :CONTENT_GENRE_ID," +
                "   :GENRE_LIST," +
                "   :CATEGORY_LIST," +
                "   :CATEGORY_ABCDE_ID," +
                "   :IS_CHILD," +
                "   :IS_RECOMMENDED," +
                "   :ACCESS_LEVEL_ID," +
                "   :CHNL_ID," +
                "   :SHORT_TYPE," +
                "   :SHORT_DESC," +
                "   :ORIG_NAME," +
                "   :IS_LIVE," +
                "   :IS_PREMIERE," +
                "   :SEASON_NUM," +
                "   :IMDB_ID," +
                "   :IMDB_RATING," +
                "   :HD_IMAGE," +
                "   :ORIGINAL_ID," +
                "   :KINOPOISK_ID," +
                "   :KINOPOISK_RATING," +
                "   :COMPANY)");

        updateProgram = ctx.getSession().getPreparedStatement(
                // language=SQL
                "UPDATE CONTENT CC " +
                "SET " +
                //"   ID = CREATEOBJECT('PROGRAM'),\n" +
                //"   DISCRIMINATOR = 'PROGRAM',\n" +
                "   NAME = :NAME,\n" +
                "   PPV_EXTERNALID = :PPV_EXTERNALID,\n" +
                "   TSTV_ALLOWED = :TSTV_ALLOWED,\n" +
                "   PL_ALLOWED = :PL_ALLOWED,\n" +
                //"   EXTERNALID = :EXTERNALID,\n" +
                "   ORIGINALNAME = :ORIGINALNAME,\n" +
                "   COUNTRY_ID = :COUNTRY,\n" +
                "   DESCRIPTION = :DESCRIPTION,\n" +
                "   DESCRIPTION_LONG = :DESCRIPTION_LONG,\n" +
                "   YEAR = :YEAR,\n" +
                "   LOGO = :LOGO,\n" +
                "   BANNER = :BANNER,\n" +
                "   LINKED_DISCRIMINATOR = :LINKED_DISCRIMINATOR,\n" +
                "   PARENT_ID = :LINKED_ID,\n" +
                "   ACTORS  = :ACTORS," +
                "   DIRECTOR = :DIRECTOR," +
                "   SCREENPLAY = :SCREENPLAY," +
                "   OPERATOR = :OPERATOR," +
                "   COMPOSER = :COMPOSER," +
                "   PRODUCER = :PRODUCER," +
                "   LEADING = :LEADING," +
                "   IS_PUBLISHED = :IS_PUBLISHED," +//
                "   BUNDLE_NAME = :BUNDLE_NAME," +
                "   SERIES_NUMBER = :SERIES_NUMBER," +
                "   SEASON_NUMBER = :SEASON_NUMBER," +
                "   SEASON_SERIES_NUMBER = :SEASON_SERIES_NUMBER," +
                "   EPISODENAME = :EPISODENAME," +
                "   GENRE_ID = :GENRE_ID," +
                "   CONTENT_GENRE_ID = :CONTENT_GENRE_ID," +
                "   GENRE_LIST = :GENRE_LIST," +
                "   CATEGORY_LIST = :CATEGORY_LIST," +
                "   CATEGORY_ABCDE_ID = :CATEGORY_ABCDE_ID," +
                "   IS_CHILD = :IS_CHILD," +
                "   IS_RECOMMENDED = :IS_RECOMMENDED," +
                "   ACCESS_LEVEL_ID = :ACCESS_LEVEL_ID," +
                "   CHNL_ID = :CHNL_ID," +
                "   SHORT_TYPE = :SHORT_TYPE," +
                "   SHORT_DESC = :SHORT_DESC," +
                "   ORIG_NAME = :ORIG_NAME," +
                "   IS_LIVE = :IS_LIVE," +
                "   IS_PREMIERE = :IS_PREMIERE," +
                "   SEASON_NUM = :SEASON_NUM," +
                "   IMDB_ID = :IMDB_ID," +
                "   IMDB_RATING = :IMDB_RATING," +
                "   HD_IMAGE = :HD_IMAGE," +
                "   ORIGINAL_ID = :ORIGINAL_ID," +
                "   KINOPOISK_ID = :KINOPOISK_ID," +
                "   KINOPOISK_RATING = :KINOPOISK_RATING, \n" +
                "   COMPANY = :COMPANY \n" +
                "WHERE " +
                " CC.ID = :CONTENT_ID "
        );

        insertEpg = ctx.getSession().getPreparedStatement(
                // language=SQL
                "INSERT INTO SCHEDULE\n" +
                "  (ID,\n" +
                "   DISCRIMINATOR,\n" +
                "   LIVE,\n" +
                "   REPEAT,\n" +
                "   FIRSTSHOWING,\n" +
                "   LASTSHOWING,\n" +
                "   FREE,\n" +
                "   SERVICE_SPEC_ID,\n" +
                "   CONTENT_ID,\n" +
                "   START_DATE,\n" +
                "   STOP_DATE,\n" +
                "   EXTERNALID,\n" +
                "   LOCATION_ID,\n" +
                "   SECTION,\n" +
                "   IS_PUBLISHED)\n" +
                "VALUES\n" +
                "  (createobject(:DISCRIMINATOR),\n" +
                "   :DISCRIMINATOR,\n" +
                "   :LIVE,\n" +
                "   :REPEAT,\n" +
                "   :FIRSTSHOWING,\n" +
                "   :LASTSHOWING,\n" +
                "   :FREE,\n" +
                "   :SERVICE_SPEC_ID,\n" +
                "   :CONTENT_ID,\n" +
                "   :START_DATE,\n" +
                "   :STOP_DATE,\n" +
                "   :EXTERNALID,\n" +
                "   :LOCATION_ID,\n" +
                "   :SECTION,\n" +
                "   :IS_PUBLISHED)");

        updateEpg = ctx.getSession().getPreparedStatement(
                // language=SQL
                "UPDATE SCHEDULE SS \n" +
                "SET " +
                //"   ID = createobject('EPG'),\n" +
                //"   DISCRIMINATOR = 'EPG',\n" +
                "   LIVE = :LIVE,\n" +
                "   REPEAT = :REPEAT,\n" +
                "   FIRSTSHOWING = :FIRSTSHOWING,\n" +
                "   LASTSHOWING = :LASTSHOWING,\n" +
                "   FREE = :FREE,\n" +
                //"   SERVICE_SPEC_ID = :SERVICE_SPEC_ID,\n" +
                //"   CONTENT_ID = :CONTENT_ID,\n" +
                "   START_DATE = :START_DATE,\n" +
                "   STOP_DATE = :STOP_DATE,\n" +
                //"   EXTERNALID = :EXTERNALID,\n" +
                //"   LOCATION_ID = :LOCATION_ID,\n" +
                //"   SECTION = :SECTION,\n" +
                "   IS_PUBLISHED = :IS_PUBLISHED\n" + // 4 чтобы проставилось
                "WHERE " +
                " SS.ID = :SCHEDULE_ID "
        );

        insertTaskImportLogo = ctx.getSession().getPreparedStatement(
                // language=SQL
                "INSERT\n" +
                "INTO\n" +
                "    TASK_IMPORT_LOGO\n" +
                "    (\n" +
                "        LOGO,\n" +
                "        URL,\n" +
                "        CNT,\n" +
                "        DSC,\n" +
                "        START_DATE,\n" +
                "        STOP_DATE,\n" +
                "        DISCRIMINATOR,\n" +
                "        CONTENT_ID,\n" +
                "        DESIGNATOR\n" +
                "    )\n" +
                "    VALUES\n" +
                "    (\n" +
                "        :LOGO,\n" +
                "        :URL,\n" +
                "        :CNT,\n" +
                "        :DSC,\n" +
                "        :START_DATE,\n" +
                "        :STOP_DATE,\n" +
                "        'EPGIMAGE', \n " +
                "        :CONTENT_ID, \n " +
                "        :DESIGNATOR        \n" +
                "    )"
        );

        getProgramForUpdate = ctx.getSession().getPreparedStatement(
                // language=SQL
                "   SELECT C.ID, S.ID, C.LOGO, C.BANNER FROM " +
                "       SCHEDULE S" +
                "       JOIN CONTENT C ON C.ID = S.CONTENT_ID " +
                "   WHERE " +
                "       S.IS_PUBLISHED = 1 AND C.IS_PUBLISHED = 1 /* IN (1,4) */ " +
                "       AND C.EXTERNALID =  :EXTERNALID " +
                "       AND S.SERVICE_SPEC_ID = :SERVICE_SPEC_ID " +
                "       AND S.LOCATION_ID = :LOCATION_ID  " +
                "       AND S.SECTION = :SECTION " +
                "       AND S.DISCRIMINATOR = :DISCRIMINATOR "
        );

        mergeTaskImportLogo = ctx.getSession().getPreparedStatement(
                // language=SQL
                "MERGE INTO TASK_IMPORT_LOGO TIL  " +
                "USING ( " +
                "       SELECT :ID C_ID, :DISCR DISCRIMINATOR, :URL URL FROM DUAL " +
                "   ) X " +
                "ON (TIL.CONTENT_ID = X.C_ID AND TIL.DISCRIMINATOR = X.DISCRIMINATOR ) " +
                "WHEN MATCHED THEN " +
                "UPDATE SET " +
                "   TIL.URL = X.URL " +
                "  DELETE WHERE X.URL IS NULL " +  // удаляем те урлы, которые обнулилися
                "WHEN NOT MATCHED THEN " +
                "INSERT ( " +
                //"   ID, " + // SEQ_TASK_IMPORT_LOGO.nextval тут вставляется
                "   TIL.DISCRIMINATOR, " +
                "   TIL.CONTENT_ID, " +
                "   TIL.URL," +
                "   TIL.CNT " +
                ") VALUES ( " +
                "   X.DISCRIMINATOR, " +
                "   X.C_ID, " +
                "   X.URL, " +
                "   0 " +
                ") WHERE X.URL IS NOT NULL " +  // вставляем только непустые урлы
                " "
        );
    }

    public CommandResult invoke(ExecutionContext ctx, Map<String, String> params) {

        CommandResult result;
        try {
            channelCache.clear();
            countryCache.clear();
            programGenreCache.clear();
            programContentGenreCache.clear();
            categoryCache.clear();
            tagCache.clear();
            accessLevelCache.clear();
            imagesLoadedCache.clear();

            currentParams = params;

            prefix = ParamHelper.getStringParam(currentParams, "import.epg.image.prefix", "");

            ctx.getSession().startTransaction();

            EpgDao epgDao = epgDaoFactory.apply(ctx.getSession());
            minAccessLevel = epgDao.getMinAccessLevelDictionaryId();

            precompileStmpts1(ctx);
            loadChannels(ctx);
            ExecutionContext newCtx = null;
            // получили список только тех каналов, которые у нас есть и надо обновить.
            Node channelsNode = Node.makeElement("channels");

            boolean throwTestExceptionForChannel = ParamHelper.getParam(params, "importPppEpg.throwTestExceptionForChannel", "importPppEpg.throwTestExceptionForChannel", "0").equals("1");
            boolean throwTestExceptionForAll = ParamHelper.getParam(params, "importPppEpg.throwTestExceptionForAll", "importPppEpg.throwTestExceptionForAll", "0").equals("1");

            if (throwTestExceptionForAll) {
                throw new Exception("test exception thrown for all");
            }

            for (Channel channel : channelCache) {
                try {
                    resetTiming();

                    long t1 = System.currentTimeMillis();

                    if (Boolean.valueOf(ParamHelper.getStringParam(currentParams, "import.epg.channel.generate_new_session_for_channel", "true"))) {
                        newCtx = new ExecutionContext(ctx.getModel());
                    } else {
                        newCtx = ctx; // чтоб если из экселя импортим - не коммитилось после каждого канала (если вдруг несколько канало импортить придётся)
                    }

                    newCtx.getSession().startTransaction();

                    precompileStmpts2(newCtx);

                    Node channelNode = Node.makeElement("channel");
                    channelNode.addChild(Node.makeAttribute("extid", channel.getEid()));
                    channelNode.addChild(Node.makeAttribute("name", channel.getName()));
                    channelNode.addChild(Node.makeAttribute("section", String.valueOf(channel.getSection())));
                    channelNode.addChild(Node.makeAttribute("efirDate", channel.getEfirDate()));
                    channelNode.addChild(Node.makeAttribute("pppId", String.valueOf(channel.getId())));
                    channelNode.addChild(Node.makeAttribute("pppName", channel.getSdpName()));
                    channelNode.addChild(Node.makeAttribute("pppLocId", String.valueOf(channel.getLocationId())));
                    channelNode.addChild(Node.makeAttribute("isPublished", String.valueOf(channel.getIsPublished())));
                    channelNode.addChild(Node.makeAttribute("reg", String.valueOf(channel.getMrf())));

                    // --------------
                    if (throwTestExceptionForChannel) {
                        throw new Exception("test exception thrown for Channel");
                    }

                    processChannel(newCtx, channel);

                    // P.S.: возможно лучше тут после заливки каждого канала статусы schedule.IS_PUBLISHED корректировать (3 - в 0, 4 - в 1)
                    // Иначе статусы ЗАКОММИЧЕННЫМИ с IS_PUBLISHED=3/4 некоторое время висят пока не заимпортятся епг для ВСЕХ каналов
                    // а еще наверное лучше сразу их в 0/1 ставить. Но пока оставлю как есть все
                    if (correctScheduleStatusesAfterEachChannel()) {
                        correctProgramStatuses(newCtx);
                    }

                    // --------------

                    channelNode.addChild(Node.makeAttribute("removed", String.valueOf(removeCount)));
                    channelNode.addChild(Node.makeAttribute("updated", String.valueOf(updateCount)));
                    channelNode.addChild(Node.makeAttribute("added", String.valueOf(addCount)));
                    channelNode.addChild(Node.makeAttribute("version", Long.toString(new Date().getTime() / 1000)));
                    channelsNode.addChild(channelNode);
                    newCtx.getSession().commit();

                    long t2 = System.currentTimeMillis();
                    timeFull = t2 - t1;

                    if (log.isInfoEnabled()) {
                        log.info(
                                "+++STAT:" +
                                channel.getEid() +
                                " t_dbInsert=" + timeDbInsert +
                                " t_dbUpdate=" + timeDbUpdate +
                                " t_dbSelect=" + timeDbSelect +
                                " t_LoadXml=" + timeLoadXml +
                                " t_LoadPic=" + timeLoadPic +
                                " t_full=" + timeFull
                        );
                    }
                } catch (Exception e) {
                    newCtx.getSession().rollback();
                    log.error("ERROR PROCESS:" + channel.toString(), e);
                    if (Boolean.valueOf(ParamHelper.getStringParam(currentParams, "import.epg.catch.channel.exception", "false"))) {
                        throw e;
                    }
                } finally {
                    try {
                        closeNullableStatement(getExternalIdsOfPublishedEpg, insertProgram, updateProgram, insertEpg,
                                updateEpg, insertTaskImportLogo, mergeChannelImportLog, getProgramForUpdate,
                                mergeTaskImportLogo);
                    } catch (Exception e) {
                        log.error(e.getMessage(), e);
                        newCtx.getSession().rollback();
                    }
                    newCtx.getSession().close();
                }
            }

            correctProgramStatuses(ctx);
            ctx.getSession().commit();

            result = new CommandResult(Node.makeElement("rows", list(channelsNode)));
            log.info("IMPORT_FINAL_RESULT: \n" + "epgSource = " + ParamHelper.getStringParam(currentParams, "import.epg.epgSource", "ppp") + " \n" + "channelsInfo = \n[\n" + channelsNode + "\n]");
        } catch (Exception e) {
            log.error(e.getMessage(), e);
            ctx.getSession().rollback();
            result = Command.makeResultFromException(e);
        } finally {
            try {
                closeNullableStatement(findChannels);
            } catch (Exception e) {
                log.error(e.getMessage(), e);
                ctx.getSession().rollback();
                result = Command.makeResultFromException(e);
            }
            ctx.getSession().close();
        }

        return result;
    }

    private void resetTiming() {
        timeDbInsert = 0;
        timeDbUpdate = 0;
        timeDbSelect = 0;
        timeLoadXml = 0;
        timeLoadPic = 0;
        timeFull = 0;
    }

    private static void closeNullableStatement(NamedParameterPreparedStatement... statements) throws SQLException {
        for (NamedParameterPreparedStatement it : statements) {
            if (it != null) {
                it.close();
            }
        }
    }

    // Переводит временное состояние IS_PUBLISHED 3 -> 0, 4 -> 1
    private static void correctProgramStatuses(ExecutionContext ctx) throws Exception {
        String update2 = "   UPDATE CONTENT CC\n" +
                         "      SET CC.IS_PUBLISHED = 0\n" +
                         "    WHERE CC.ID IN (SELECT CONTENT_ID FROM SCHEDULE WHERE IS_PUBLISHED = 3)\n";

        String update3 = "   UPDATE SCHEDULE SET IS_PUBLISHED = DECODE(IS_PUBLISHED, 3, 0, 1)\n" +
                         "   WHERE IS_PUBLISHED IN (3, 4)";

        ctx.getSession().executeUpdate(update2);
        ctx.getSession().executeUpdate(update3);
    }


    /**
     * загружаем список каналов и проверяем какие из них изменились.
     */
    private void loadChannels(ExecutionContext ctx) throws Exception {
        Object helpObject = ctx.getHelpObject();

        IndexDocument indexD;

        // в первом случае мы загружаем xml из сети
        if (helpObject == null) {
            String l = ConfigurationHelper.getProperty("l", "111");
            String p = ConfigurationHelper.getProperty("p", "111");
            String url = ConfigurationHelper.getProperty("url", "someurl");
            ByteArrayInputStream data = new ByteArrayInputStream(stvEpgHttpClientForData.get(url + "?l=" + l + "&p=" + p));
            indexD = IndexDocument.Factory.parse(data);

            // во втором случае мы получаем его прямо из контекста
        } else {
            indexD = (IndexDocument) helpObject; // преобразуем в документ xml
        }


        IndexDocument.Index.File[] files = indexD.getIndex().getFileArray();
        for (IndexDocument.Index.File f : files) {
            // проверяем что у нас тут с каналом, надо ли для него грузить EPG
            processCheckChannel(ctx, f);
        }
    }

    /**
     * Проверяем что у нас тут с каналом, надо ли для него грузить EPG
     */
    private void processCheckChannel(ExecutionContext ctx, IndexDocument.Index.File file) throws Exception {

        // выбираем список каналов и время последнего обновления подходящие под условия.
        long time = FORMAT_DATE.parse(file.getEfirDate()).getTime();
        Integer section = Long.valueOf(time / 1000).intValue();

        try (ResultSet rs = ctx.getSession().executeNPPS(findChannels,
                bind("SECTION", section),
                bind("EID", file.getChannel()))) {

            Date stvDate = FORMAT.parse(file.getDateTime());

            // Импортируем передачи только в указанном интервале
            boolean ignoreStartStopDate = Boolean.parseBoolean(ParamHelper.getStringParam(currentParams, "ignoreStartStopDate", "false"));
            Date processEpgFromDate = (!ignoreStartStopDate && file.getProcessEpgFromDate() != null) ? FORMAT.parse(file.getProcessEpgFromDate()) : null;
            Date processEpgToDate = (!ignoreStartStopDate && file.getProcessEpgToDate() != null) ? FORMAT.parse(file.getProcessEpgToDate()) : null;

            boolean reImportUnchangedChannels = ParamHelper.getParam(currentParams, "reImportUnchangedChannels", "import.stv.epg.reImportUnchangedChannels", "0").equals("1");

            List<Integer> validChannelPublishedStatuses = CollectionsHelper.convertStringToInt(ParamHelper.getStringParam(currentParams, "validChannelPublishedStatuses", "1"), ",");
            while (rs.next()) {
                Date dbDate = rs.getTimestamp(4);
                Integer isPublished = rs.getInt(6);
                String mrf = rs.getString(7);

                if (validChannelPublishedStatuses.contains(isPublished)) {

                    // если это импорт всего EPG и время в бд меньше времени от поставщика(или мы забиваем на проверку времени), добаляем в список загружаемых каналов.
                    // || или если это импорт EPG только 1 канала и текущий канал=требуемому - добаляем в список загружаемых каналов
                    if ((!isSingleImport() && (stvDate.getTime() > dbDate.getTime() || reImportUnchangedChannels))
                        || (isSingleImport() && extendedChannelCondition(file))) {
                        channelCache.add(
                                new Channel(
                                        rs.getInt(1), // id
                                        rs.getString(2), // ext id
                                        rs.getInt(3), // location
                                        rs.getString(5), // channel name
                                        section, // section
                                        file.getEfirDate(), // section Date Value
                                        file.getName(), // url
                                        file.getTVGrid(), // TVGrid
                                        stvDate,
                                        file.getChannelName(),
                                        processEpgFromDate,
                                        processEpgToDate,
                                        file.getEpgType() != null ? file.getEpgType() : EPG_SIMPLE_TYPE,
                                        isPublished,
                                        mrf
                                )
                        );
                    }
                }
            }
        }
    }

    protected boolean extendedChannelCondition(IndexDocument.Index.File f) {
        return false;
    }

    // информирует, что это метод полной загрузки EPG
    protected boolean isSingleImport() {
        return false;
    }

    // вычисляем - является ли импорт форсированным, т.е. для всех передач обязательный переимпорт
    private boolean isForceImport() {
        return Boolean.valueOf(ParamHelper.getStringParam(currentParams, "import.epg.force", "false")); // по умолчанию - обычный импорт
    }

    // вычисляем - использовать ли при импорте смёрживание существующих передач
    private boolean isMergeModeImport() {
        return Boolean.valueOf(ParamHelper.getParam(currentParams, "import.epg.merge", "import.epg.merge", "false")); // по умолчанию - не мёржим, существующие передачи скипим  (берет из параметров, если там нет - берет из мяса)
    }

    // перезагружать ли картинки (заменяя их имена) - чтобы ноды nginx-а не перетиради их
    private boolean guaranteeReloadImages() {
        return Boolean.valueOf(ParamHelper.getStringParam(currentParams, "import.epg.guaranteeReloadImages", "false"));
    }

    // корректировать ли статусы передач после заливки каждого канала
    private boolean correctScheduleStatusesAfterEachChannel() {
        return ParamHelper.getStringParam(currentParams, "import.epg.correctScheduleStatusesAfterAllChannel",
                ConfigurationHelper.getProperty("import.epg.correctScheduleStatusesAfterAllChannel", "1")).equals("1"); // чтобы статусы корректировались 3=>0 4=>1 после каждого канала. Так менее оптимально, но не критично! Зато каждый канал будет обработан полностью атомарно
    }

    // корректировать stopDate крайней передачи до интервала и у последней передачи интервала
    private boolean correctStopDate() {
        return ParamHelper.getStringParam(currentParams, "import.epg.correctStopDate",
                ConfigurationHelper.getProperty("import.epg.correctStopDate", "0")).equals("1");
    }

    /**
     * теперь нужно проверить, какие именно ID у нас уже есть вбазе, а каких нет.
     * для этого делаем большах селект на список ID которые мы обновили. так как их очень много то нашу сепер модель не используем
     */
    private Set<String> getExternalIdsOfPublishedEpg(ExecutionContext ctx, Channel channel) throws SQLException {
        Set<String> curIdSet = new HashSet<>();
        try (ResultSet rs = ctx.getSession().executeNPPS(getExternalIdsOfPublishedEpg,
                bind("SS", channel.getId()),
                bind("LOC", channel.getLocationId()),
                bind("SECTION", channel.getSection()),
                bind("DISCRIMINATOR", getEpgDiscrByType(channel.getEpgType())),
                bind("PROCESS_EPG_FROM_DATE", channel.getProcessEpgFromDate()),
                bind("PROCESS_EPG_TO_DATE", channel.getProcessEpgToDate()))) {

            while (rs.next()) {
                curIdSet.add(rs.getString(1));
            }
        }
        return curIdSet;
    }

    /**
     * загружаем EPG для канала.
     */
    private void processChannel(ExecutionContext ctx, Channel channel) throws Exception {

        Set<String> curIdSet = getExternalIdsOfPublishedEpg(ctx, channel);

        /* форсированная загрузка EPG для одного канала */
        // сохраняем сет с ID передач во временную переменную
        Set<String> curIdSetForSingleImport = curIdSet;
        // если это операция по загрузке EPG только для одного канала,
        // или это форсированный импорт
        // то очищаем список ID передач, чтобы загрузились ВСЕ передачи (а не только новые)
        if ((isSingleImport() && !isMergeModeImport()) || isForceImport()) {
            curIdSet = new HashSet<>(); // "new HashSet()" вместо "curIdSet.clear()" для того, чтобы curIdSet указывал на другой адрес в памяти, А Иначе curIdSetForSingleImport тоже очистится
        }

        long t1 = System.currentTimeMillis();

        // TVGrid и url(name) - взаимозаменяемые. Если найден TVGrid - используется он, иначе по url xml загружается из сети
        TVGridType tvGrid = getTvGridType(channel);
        TVGridType.Event[] events = tvGrid.getEventArray();

        long t2 = System.currentTimeMillis();
        timeLoadXml = timeLoadXml + (t2 - t1);
        // надо опубликовать обратно все EPG
        removeCount = 0;
        updateCount = 0;
        addCount = 0;

        minStartDateScheduleId = null;
        minStartDate = null;
        maxStartDateScheduleId = null;
        maxStartDate = null;

        for (TVGridType.Event event : events) {
            processEvent(ctx, channel, event, curIdSet);
        }

        // если это операция по форсированной загрузке EPG только для одного канала
        // или это форсированный импорт,
        // то восстанавливаем значения списка ID
        if ((isSingleImport() && !isMergeModeImport()) || isForceImport()) {
            curIdSet = curIdSetForSingleImport;
        }
        removeCount = curIdSet.size();

        // ---------------------------------------------------------------------------
        // РАСПУБЛИКАЦИЯ
        // ---------------------------------------------------------------------------
        // в этом сете у нас остались только те ID которые надо распубликовать
        if (curIdSet.size() > 0) {
            Collection<ParameterBinding> bindings = set(
                    bind("SS", channel.getId()),
                    bind("LOC", channel.getLocationId()),
                    bind("SECTION", channel.getSection()),
                    new StringParameterBinding("DISCRIMINATOR", getEpgDiscrByType(channel.getEpgType()) /*!channel.isBarker ? "EPG" : "BARKEREPG"*/),
                    new DateTimeParameterBinding("PROCESS_EPG_FROM_DATE", channel.getProcessEpgFromDate()),
                    new DateTimeParameterBinding("PROCESS_EPG_TO_DATE", channel.getProcessEpgToDate())
            );

            t1 = System.currentTimeMillis();

            StringBuilder updatePart = new StringBuilder(
                    "UPDATE SCHEDULE S\n" +
                    "   SET S.IS_PUBLISHED = 3 \n" // АХТУНГ !!! статус 3  (предварительная распубликация
            );
            StringBuilder wherePart = new StringBuilder(
                    GET_SCHEDULE_FOR_PARAMS_WHERE_PART +  //вернул обратно. Иначе при переимпорте(import_stv_epg_channel) передачи затираются
                    "   AND ("
            ).append(DbCommand.getLongInClauseStr("S.EXTERNALID", curIdSet, bindings, "EID")).append(" )");

            // затем распубликовываем ненужные программы передач
            StringBuilder updateSql = new StringBuilder().append(updatePart).append(wherePart);
            ctx.getSession().executeUpdate(updateSql.toString(), bindings);

            t2 = System.currentTimeMillis();
            timeDbUpdate = timeDbUpdate + (t2 - t1);
        }

        // корректируем stopDate у крайней передачи перед интервалом и у последней передачи интервала
        correctStopDates(ctx, channel);

        // типа всё заимпортили, теперь обновляем инфу о последнем обновлении инфы о канале
        updateChannelImportLog(ctx, channel);
    }

    private void processEvent(ExecutionContext ctx, Channel channel, TVGridType.Event event, Set<String> curIdSet) throws Exception {
        String eventId = event.getID();
        // если такой id у нас есть то удаляем из сета
        if (curIdSet.contains(eventId)) {
            curIdSet.remove(eventId);

            if (isMergeModeImport()) {
                updateExistingEpg(ctx, channel, event);
                updateCount++;
            }
        } else {
            addNewEpg(ctx, channel, event);
            addCount++;
        }
    }

    private TVGridType getTvGridType(Channel channel) throws Exception {
        TVGridType tvGrid;
        // если задан только URL - то берем программу передач из инета
        if (channel.getTvGrid() == null) {
            byte[] bdata = pppEpgHttpClientForData.get(channel.getUrl());
            ByteArrayInputStream data = new ByteArrayInputStream(bdata);
            try {
                TVGridDocument gridDoc = TVGridDocument.Factory.parse(data);
                tvGrid = gridDoc.getTVGrid();
            } catch (Exception e) {
                // скидываем трейс
                String traceName = ConfigurationHelper.getProperty("prp.trace.dir", "/var/log/prp/trace/") + "ppp" + channel.getUrl().hashCode() + ".xml";
                log.error("Error parse url:" + channel.getUrl() + "look at trace:" + traceName);
                try (FileOutputStream fos = new FileOutputStream(traceName)) {
                    fos.write(bdata);
                    fos.flush();
                } catch (Exception ex) {
                    log.error(e.getMessage(), ex);
                }
                throw e;
            }

            // иначе берем прграмму передач из вложения
        } else {
            tvGrid = channel.getTvGrid();
        }
        return tvGrid;
    }


    private void updateChannelImportLog(ExecutionContext ctx, Channel c) throws SQLException {
        ctx.getSession().executeNPPSUpdate(mergeChannelImportLog,
                set(new DateTimeParameterBinding("LAST_UPD", c.getStvDate()),
                        bind("SECTION", c.getSection()),
                        new StringParameterBinding("CHANNEL_EXT", c.getEid())));
    }

    private void correctStopDates(ExecutionContext ctx, Channel c) throws SQLException {
        if (correctStopDate()) {
            Collection<ParameterBinding> bindings = set(
                    bind("SS", c.getId()),
                    bind("LOC", c.getLocationId()),
                    bind("SECTION", c.getSection()),
                    new StringParameterBinding("DISCRIMINATOR", getEpgDiscrByType(c.getEpgType()) /*!c.isBarker ? "EPG" : "BARKEREPG"*/),
                    new DateTimeParameterBinding("PROCESS_EPG_FROM_DATE", minStartDate),
                    new DateTimeParameterBinding("PROCESS_EPG_TO_DATE", maxStartDate),
                    bind("S_ID_MIN", minStartDateScheduleId),
                    bind("S_ID_MAX", maxStartDateScheduleId)
            );
            if (c.getProcessEpgFromDate() != null) {
                ctx.getSession().executeUpdate(
                        "UPDATE \n" +
                        "    SCHEDULE S22 \n" +
                        "SET" +
                        "   S22.STOP_DATE = :PROCESS_EPG_FROM_DATE " +
                        "WHERE\n" +
                        "    S22.START_DATE = \n" +
                        "    (\n" +
                        "        SELECT\n" +
                        "            MAX(S2.START_DATE)\n" +
                        "        FROM\n" +
                        "            SCHEDULE S2\n" +
                        "        WHERE\n" +
                        "            S2.START_DATE      < :PROCESS_EPG_FROM_DATE \n" +
                        "        AND S2.SERVICE_SPEC_ID = :SS \n" +
                        "        AND S2.SECTION = :SECTION \n" +
                        "        AND S2.LOCATION_ID     = :LOC \n" +
                        "        AND S2.DISCRIMINATOR   = :DISCRIMINATOR \n" +
                        "        AND S2.IS_PUBLISHED    in (1,4) \n" +
                        "    )\n" +
                        "AND S22.SERVICE_SPEC_ID = :SS \n" +
                        "AND S22.LOCATION_ID     = :LOC \n" +
                        "AND S22.SECTION = :SECTION \n" +
                        "AND S22.DISCRIMINATOR   = :DISCRIMINATOR \n" +
                        "AND S22.IS_PUBLISHED   IN (1,4) ",
                        bindings
                );
            }
            if (c.getProcessEpgToDate() != null) {
                ctx.getSession().executeUpdate(
                        "UPDATE \n" +
                        "    SCHEDULE S22 \n" +
                        "SET \n" +
                        "   S22.STOP_DATE = \n" +
                        "      COALESCE (  \n" +
                        "           (SELECT  \n" +
                        "               MIN(S2.START_DATE) \n" +
                        "           FROM \n" +
                        "               SCHEDULE S2 \n" +
                        "           WHERE \n" +
                        "               S2.START_DATE      > :PROCESS_EPG_TO_DATE \n" +
                        "           AND S2.SERVICE_SPEC_ID = :SS \n" +
                        "           AND S2.SECTION = :SECTION \n" +
                        "           AND S2.LOCATION_ID     = :LOC \n" +
                        "           AND S2.DISCRIMINATOR   = :DISCRIMINATOR \n" +
                        "           AND S2.IS_PUBLISHED    in (1,4) )  \n" +
                        "           ,  " +
                        "           S22.STOP_DATE ) \n" +
                        "WHERE \n" +
                        "    S22.ID = :S_ID_MAX \n"
                        //"AND S22.SERVICE_SPEC_ID = :SS \n" +
                        //"AND S22.LOCATION_ID     = :LOC \n" +
                        //"AND S22.SECTION = :SECTION \n" +
                        //"AND S22.DISCRIMINATOR   = :DISCRIMINATOR \n" +
                        //"AND C22.IS_PUBLISHED   IN (1,4) "
                        , bindings
                );
            }
        }


    }


    private static final int INSERT_EPG_ACTION = 1;
    private static final int UPDATE_EPG_ACTION = 2;

    private Long maxStartDateScheduleId;
    private Date maxStartDate;
    private Long minStartDateScheduleId;
    private Date minStartDate;


    private void updateExistingEpg(ExecutionContext ctx, Channel c, TVGridType.Event e) throws Exception {
        mergeIntoEpg(ctx, c, e, UPDATE_EPG_ACTION);
    }

    private void addNewEpg(ExecutionContext ctx, Channel c, TVGridType.Event e) throws Exception {
        mergeIntoEpg(ctx, c, e, INSERT_EPG_ACTION);
    }

    private String generateLogoName(String extId) {
        String postfix = UUID.randomUUID().toString();
        if (postfix.length() > 5) {
            postfix = postfix.substring(0, 5);
        }
        String logoName = prefix + IMAGE_FILENAME_PREFIX + extId + "_" + postfix + ".jpg";
        return logoName;
    }


    /**
     * добаваляем EPG.
     */
    private void mergeIntoEpg(ExecutionContext ctx, Channel channel, TVGridType.Event event, int actionType) throws Exception {

        if (log.isDebugEnabled()) {
            log.debug("Start process event: " + event.getID());
        }
        try {
            String extId = event.getID();
            String programDiscriminator = getProgramDiscrByType(channel.getEpgType());
            String scheduleDiscriminator = getEpgDiscrByType(channel.getEpgType());

            long programId = 0;
            long epgId = 0;
            String existingLogoName = "";
            String existingBannerName = "";
            if (actionType == UPDATE_EPG_ACTION) {
                List<List<String>> qresCid = ctx.getSession().executeNPPStoList(getProgramForUpdate,
                        set(
                                new StringParameterBinding("EXTERNALID", extId),
                                bind("LOCATION_ID", channel.getLocationId()),
                                new StringParameterBinding("SECTION", channel.getSection()),
                                new StringParameterBinding("DISCRIMINATOR", scheduleDiscriminator),
                                bind("SERVICE_SPEC_ID", channel.getId())
                        ));

                programId = Integer.valueOf(qresCid.get(1).get(0));
                epgId = Integer.valueOf(qresCid.get(1).get(1));
                existingLogoName = qresCid.get(1).get(2);
                existingBannerName = qresCid.get(1).get(3);

            }


            // добавляем контент
            String eventName = event.getName();
            // внешний идентификатор ценовой категории (для услуги Pay Per View)
            String PPVExtId = event.getPPVExtId();

            Long TSTVAllowed = null;
            Long PLAllowed = null;
            if (channel.getEpgType() == null || EPG_SIMPLE_TYPE.equals(channel.getEpgType())) {
                // получаем доступность TSTV на передаче
                String TSTVAllowedStr = event.getTSTVAllowed();
                // чтоб не было путаницы - если ничего не передано - ставим 1(по умолчанию ДОСТУПНО). Пусть те передачи где ТСТВ и ПаузЛайв не доступен - при импорте посылают 0
                TSTVAllowed = (TSTVAllowedStr != null && !TSTVAllowedStr.isEmpty()) ? Long.valueOf(TSTVAllowedStr) : 1;  

                // получаем доступность PL на передаче
                String PLAllowedStr = event.getPLAllowed();
                // чтоб не было путаницы - если ничего не передано - ставим 1(по умолчанию ДОСТУПНО). Пусть те передачи где ТСТВ и ПаузЛайв не доступен - при импорте посылают 0
                PLAllowed = (PLAllowedStr != null && !PLAllowedStr.isEmpty()) ? Long.valueOf(PLAllowedStr) : 1; 
            }

            String linkedDiscriminator = null;
            String linkedId = null;
            TVGridType.Event.Promo promo = event.getPromo();
            if (promo != null) {
                linkedDiscriminator = promo.getLinkedDiscriminator();
                linkedId = promo.getLinkedId();
            }

            long star = event.getStar();
            int ir = 0;
            if (star == 1L) { 
                ir = 1;
            }
            Date startDate = FORMAT_EVENT.parse(event.getStart());
            Date finishDate = event.getFinish() != null ? FORMAT_EVENT.parse(event.getFinish()) : null; // TODO: желательно! (для PPV) сюда всегда что-то передавать. Но пока тут может быть пусто
            // информация о, считается важнее?
            TVGridType.Event.Gate gate = event.getGate();

            // add-info
            String shortType = null;
            String shortDesc = null;
            String origName = null;
            Integer isLive = null;
            Integer isPremiere = null;
            Integer seasonNum = null;
            String imdbId = null;
            String imdbRating = null;
            String kinopoiskId = null;
            String kinopoiskRating = null;
            String hdImage = null;

            if (gate.getAddInfo() != null) {
                TVGridType.Event.Gate.AddInfo info = new AddInfoTrimmingWrapper(gate.schemaType(), gate.getAddInfo());
                shortType = info.getShortType();
                shortDesc = info.getShortDesc();
                origName = info.getOrigName();
                isLive = info.getIsLive();
                isPremiere = info.getIsPremiere();
                seasonNum = info.getSeasonNum();

                if (info.getKinopoisk() != null) {
                    kinopoiskId = info.getKinopoisk().getId();
                    kinopoiskRating = info.getKinopoisk().getRating();
                }

                if (gate.getAddInfo().getImdb() != null) {
                    imdbId = gate.getAddInfo().getImdb().getId();
                    imdbRating = gate.getAddInfo().getImdb().getRating();
                }

                if (gate.getAddInfo().getHdImage() != null) {
                    hdImage = gate.getAddInfo().getHdImage().getSrc();
                }
            }

            String originalName = gate.getTitle();
            Long countryId = getCountryId(ctx, gate.getCountry());
            //единственное место, где мы получаем "настоящий жанр передачи" ProgramGenre
            Long programGenreId = getProgramGenreId(ctx, event.getFlag());
            //остальное это ProgramContentGenre, некие субжанры, дефакто не используются в наст. момент
            Long programContentGenreId = getProgramContentGenreId(ctx, gate.getGenre());
            Long programCategoryId = getProgramCategoryId(ctx, gate.getCategory());//  амитов
            String description = gate.getInfo();
            String descriptionLong = gate.getLongInfo();
            String year = gate.getYear();
            Long accessLevelId = getAccessLevelId(ctx, gate.getPG());
            String episodeName = null;
            String bundleName = null;
            String seasonNumber = null;
            String seasonMovieNumber = null;
            String seriesUniqueId = null;
            int isChild = getIsChild(gate.getPG());

            if (event.getFlag() != null) {
                episodeName = gate.getSubTitle();
                bundleName = gate.getTitle();

                // в нашем формате импорта можно указать SeriesUniqueId
                seriesUniqueId = gate.getSeriesUniqueId();
                seasonNumber = gate.isSetSeasonNumber() ? gate.getSeasonNumber() : null;
                seasonMovieNumber = gate.isSetSeasonMovieNumber() ? gate.getSeasonMovieNumber() : null;
            }
            String logo = "";
            String banner = "";
            long t1 = System.currentTimeMillis();
            List<ImageWrapper> loadQueue = new ArrayList<>();
            try {
                String logoName;
                String bannerName;

                String delim = converterContext != null ? converterContext.getDelimiterOfElements() : "*";

                if (guaranteeReloadImages()) {  // если картинки нужно гарантированно переимпортить - то генерим уникальное имя картинки, чтобы эта конструкция работала с нодами

                    String postfix = UUID.randomUUID().toString();
                    if (postfix.length() > 5) {
                        postfix = postfix.substring(0, 5);
                    }

                    logoName = prefix + IMAGE_FILENAME_PREFIX + extId + "_" + postfix + ".jpg";
                    bannerName = prefix + BANNER_FILENAME_PREFIX + extId + "_" + postfix + ".jpg";

                } else {

                    logoName = (!existingLogoName.isEmpty() && existingLogoName.indexOf(",") == -1) ? existingLogoName : prefix + IMAGE_FILENAME_PREFIX + extId + ".jpg";
                    bannerName = (!existingBannerName.isEmpty()) ? existingBannerName : prefix + BANNER_FILENAME_PREFIX + extId + ".jpg";
                }


                // Если нет hd логотипа, то загружаем в sd.
                if (StringUtils.isBlank(hdImage)) {
                    // несколько урлов картинок через разделитель
                    List<String> logoUrls = CollectionsHelper.convertStringToList(event.getGate().getImage(), delim, true);
                    if (!logoUrls.isEmpty()) {
                        if (logoUrls.size() == 1) {
                            // если только 1 урл - то по старому заменяем картинку
                            ImageWrapper imageWrapper = processImg(event, logoUrls.get(0), logoName);
                            logo = imageWrapper.logo;
                            loadQueue.add(imageWrapper);
                        } else {
                            // иначе грузим все с новым именем
                            StringBuilder screenshotsBindingName = new StringBuilder();
                            int j = 0;
                            for (String logoUrl : logoUrls) {
                                ImageWrapper imageWrapper = processImg(event, logoUrl, generateLogoName(extId));
                                String logoTmp = imageWrapper.logo;
                                loadQueue.add(imageWrapper);
                                if (logoTmp != null && !logoTmp.isEmpty()) {
                                    if (j != 0) {
                                        screenshotsBindingName.append(",");
                                    }
                                    screenshotsBindingName.append(logoTmp);
                                    j++;
                                }
                            }
                            logo = screenshotsBindingName.toString();
                        }
                    }
                } else {
                    ImageWrapper imageWrapper = processImg(event, hdImage, logoName);
                    logo = imageWrapper.logo;

                    // В hd_image сохраняем имя файла вместо ссылки на изображение из внешнего источника.
                    hdImage = imageWrapper.logo;

                    loadQueue.add(imageWrapper);
                }

                ImageWrapper imageWrapper = processImg(event, event.getGate().getBanner(), bannerName);
                banner = imageWrapper.logo;
                loadQueue.add(imageWrapper);

            } catch (Throwable ee) {
                log.error("error load: " + gate.getImage(), ee);
            }
            long t2 = System.currentTimeMillis();
            timeLoadPic = timeLoadPic + (t2 - t1);
            if (description != null && description.length() > 2000) {
                description = description.substring(0, 2000); // для русски
            }

            /* Humans */
            String actors = getActors(gate.getHumans());
            String director = getDirector(gate.getHumans());
            String operator = getOperator(gate.getHumans());
            String composer = getComposer(gate.getHumans());
            String host = getHost(gate.getHumans());
            String producer = getProducer(gate.getHumans());
            String screenplay = getScreenplay(gate.getHumans());

            String company = gate.getCompany();

            // опциональные long значения (в том числе пустые теги <GeneralID/>)
            Long live = event.isSetLive() ? event.getLive() : null;
            Long repeat = event.isSetRepeat() ? event.getRepeat() : null;
            Long firstShowing = event.isSetFirstShowing() ? event.getFirstShowing() : null;
            Long lastShowing = event.isSetLastShowing() ? event.getLastShowing() : null;
            Long free = event.isSetFree() ? event.getFree() : null;
            Long generalId = event.isSetGeneralID() && !isXmlLongNull(event.xgetGeneralID()) ? event.getGeneralID() : null;

            // добавляем остальные категории через запятую в поле контента, чтоб потом его отдавать в loadEpg (ибо отдавать из OL очень неоптимально)
            StringBuilder categoryIdsStr = new StringBuilder();
            TVGridType.Event.Categories categories = event.getCategories();
            if (categories != null) {
                Set<Long> mentionedCategoryIds = new HashSet<>();
                if (programCategoryId != null) {
                    mentionedCategoryIds.add(programCategoryId); // добавляем в список через запятую все категории кроме первой
                }
                int i = 0;
                for (TVGridType.Event.Categories.Category category : categories.getCategoryArray()) {
                    Long categoryId = getProgramCategoryId(ctx, category);
                    if (categoryId != null && !mentionedCategoryIds.contains(categoryId)) {
                        if (i > 0) {
                            categoryIdsStr.append(",");
                        }
                        categoryIdsStr.append(categoryId);
                        i++;
                        mentionedCategoryIds.add(categoryId); // добавляем чтоб id-шник не дублировался (ну мало ли)
                    }
                }
            }

            // добавляем остальные жанры через запятую в поле контента, чтоб потом его отдавать в loadEpg (ибо отдавать из OL очень неоптимально)
            StringBuilder genreIdsStr = new StringBuilder();
            TVGridType.Event.Genres genres = event.getGenres();
            if (genres != null) {
                Set<Long> mentionedContentGenreIds = new HashSet<>();
                if (programContentGenreId != null) {
                    mentionedContentGenreIds.add(programContentGenreId);
                }
                int i = 0;
                for (TVGridType.Event.Genres.Genre genre : genres.getGenreArray()) {
                    Long contentGenreId = getProgramContentGenreId(ctx, genre);
                    if (contentGenreId != null && !mentionedContentGenreIds.contains(contentGenreId)) {
                        if (i > 0) {
                            genreIdsStr.append(",");
                        }
                        genreIdsStr.append(contentGenreId);
                        i++;
                        mentionedContentGenreIds.add(contentGenreId); // добавляем чтоб id-шник не дублировался (ну мало ли)
                    }

                }
            }
            if (gate.isSetGenre()) {
                // если пришло от stv то используем его, а не амитовский.
                // категорию из жанра?
                programCategoryId = getProgramCategoryId(ctx, gate.getGenre());
            }

            // id передачи для улучшения рекомендаций. Не меняется со временем.
            Long originalId = event.isSetORIGINALID() && !isXmlLongNull(event.xgetORIGINALID()) ? event.getORIGINALID() : null;

            // контент инсертим
            t1 = System.currentTimeMillis();
            ctx.getSession().executeNPPSUpdate(actionType == INSERT_EPG_ACTION ? insertProgram : updateProgram,
                    set(
                            new StringParameterBinding("NAME", eventName),
                            new StringParameterBinding("PPV_EXTERNALID", PPVExtId),  //  внешний идентификатор ценовой категории (для услуги Pay Per View)
                            new LongParameterBinding("TSTV_ALLOWED", TSTVAllowed),  // доступность TSTV на передаче
                            new LongParameterBinding("PL_ALLOWED", PLAllowed),  // доступность PL на передаче
                            new StringParameterBinding("EXTERNALID", extId),
                            new StringParameterBinding("ORIGINALNAME", originalName),
                            new LongParameterBinding("COUNTRY", countryId),
                            new StringParameterBinding("DESCRIPTION", description),
                            new StringParameterBinding("DESCRIPTION_LONG", descriptionLong),
                            new StringParameterBinding("YEAR", year),
                            new StringParameterBinding("LOGO", logo),
                            new StringParameterBinding("BANNER", banner),
                            new StringParameterBinding("LINKED_DISCRIMINATOR", linkedDiscriminator),
                            new StringParameterBinding("LINKED_ID", linkedId),
                            new StringParameterBinding("DISCRIMINATOR", programDiscriminator),
                            new StringParameterBinding("ACTORS", actors),
                            new StringParameterBinding("DIRECTOR", director),
                            new StringParameterBinding("SCREENPLAY", screenplay),
                            new StringParameterBinding("OPERATOR", operator),
                            new StringParameterBinding("COMPOSER", composer),
                            new StringParameterBinding("PRODUCER", producer),
                            new StringParameterBinding("LEADING", host),
                            bind("IS_PUBLISHED", 1),
                            new StringParameterBinding("BUNDLE_NAME", bundleName),
                            new StringParameterBinding("SERIES_NUMBER", seriesUniqueId),
                            new StringParameterBinding("SEASON_NUMBER", seasonNumber),
                            new StringParameterBinding("SEASON_SERIES_NUMBER", seasonMovieNumber),
                            new StringParameterBinding("EPISODENAME", episodeName),
                            bind("GENRE_ID", programGenreId),
                            bind("CONTENT_GENRE_ID", programContentGenreId),
                            new StringParameterBinding("GENRE_LIST", genreIdsStr),
                            new StringParameterBinding("CATEGORY_LIST", categoryIdsStr),
                            bind("CATEGORY_ABCDE_ID", programCategoryId),
                            bind("IS_RECOMMENDED", ir),
                            new LongParameterBinding("ACCESS_LEVEL_ID", accessLevelId),
                            bind("LOCATION_ID", channel.getLocationId()),
                            new StringParameterBinding("SECTION", channel.getSection()),
                            bind("IS_CHILD", isChild),
                            bind("SERVICE_SPEC_ID", channel.getId()),
                            bind("CONTENT_ID", programId),
                            new LongParameterBinding("CHNL_ID", generalId),
                            new StringParameterBinding("SHORT_TYPE", shortType),
                            new StringParameterBinding("SHORT_DESC", shortDesc),
                            new StringParameterBinding("ORIG_NAME", origName),
                            bind("IS_LIVE", isLive),
                            bind("IS_PREMIERE", isPremiere),
                            bind("SEASON_NUM", seasonNum),
                            new StringParameterBinding("IMDB_ID", imdbId),
                            new StringParameterBinding("IMDB_RATING", imdbRating),
                            new StringParameterBinding("KINOPOISK_ID", kinopoiskId),
                            new StringParameterBinding("KINOPOISK_RATING", kinopoiskRating),
                            new StringParameterBinding("HD_IMAGE", hdImage),
                            bind("ORIGINAL_ID", originalId),
                            bind("COMPANY", company)
                    ));
            if (actionType == INSERT_EPG_ACTION) {
                programId = ctx.getSession().getLastInsertId("OBJECT");
            }
            //после того, как есть Контент, можем прогрузить картинки
            for (ImageWrapper imageWrapper : loadQueue) {
                if (imageWrapper.needLoad) {
                    imageWrapper.contentId = programId;
                    loadImg(ctx, imageWrapper);
                }
            }
            // инсертим schedule
            ctx.getSession().executeNPPSUpdate(actionType == INSERT_EPG_ACTION ? insertEpg : updateEpg,
                    set(
                            new LongParameterBinding("LIVE", live),
                            new LongParameterBinding("REPEAT", repeat),
                            new LongParameterBinding("FIRSTSHOWING", firstShowing),
                            new LongParameterBinding("LASTSHOWING", lastShowing),
                            new LongParameterBinding("FREE", free),
                            bind("SERVICE_SPEC_ID", channel.getId()),
                            bind("CONTENT_ID", programId),
                            new DateTimeParameterBinding("START_DATE", startDate),
                            new DateTimeParameterBinding("STOP_DATE", finishDate),
                            new StringParameterBinding("EXTERNALID", extId),
                            new StringParameterBinding("DISCRIMINATOR", scheduleDiscriminator),
                            bind("LOCATION_ID", channel.getLocationId()),
                            new StringParameterBinding("SECTION", channel.getSection()),
                            bind("IS_PUBLISHED", 4), // потом по нему сформируем дельту.!!! WARNING! не менять на 1, оставить 4!!!
                            bind("SCHEDULE_ID", epgId)
                    ));
            if (actionType == INSERT_EPG_ACTION) {
                epgId = ctx.getSession().getLastInsertId("OBJECT");
            }

            processLinks(ctx, event, actionType, programId);

            // обрабатываем сохранение урл картинки - чтобы потом заэкспортить можно было
            saveImagesUrl(ctx, channel, event, programId);

            t2 = System.currentTimeMillis();
            timeDbInsert = timeDbInsert + (t2 - t1);

            if (maxStartDate == null || startDate.getTime() > maxStartDate.getTime()) {
                maxStartDate = startDate;
                maxStartDateScheduleId = epgId;
            }
            if (minStartDate == null || startDate.getTime() < minStartDate.getTime()) {
                minStartDate = startDate;
                minStartDateScheduleId = epgId;
            }


        } catch (Exception ex) {
            log.error("Error process:\n" + event.toString(), ex.getMessage());
            throw ex;
        }

    }

    private void processLinks(ExecutionContext ctx, TVGridType.Event event, int actionType, long programId) throws Exception {
        if (actionType == UPDATE_EPG_ACTION) {
            CommonDAO.delChildFromObjectLink(ctx.getSession(), "PROGRAMINPROGRAMCATEGORY", programId); 
            CommonDAO.delChildFromObjectLink(ctx.getSession(), "PROGRAMINPROGRAMCONTENTGENRE", programId);
            CommonDAO.delChildFromObjectLink(ctx.getSession(), "CONTENTINTAG", programId);
        }

        // добавляем категории к программе
        TVGridType.Event.Categories categories = event.getCategories();
        if (categories != null) {
            for (TVGridType.Event.Categories.Category category : categories.getCategoryArray()) {
                Long objId = getProgramCategoryId(ctx, category);
                if (objId != null) {
                    CommonDAO.mergeIntoObjectLink(ctx.getSession(), "PROGRAMINPROGRAMCATEGORY", objId, programId);
                }
            }
        }

        // добавляем жанры к программе
        TVGridType.Event.Genres genres = event.getGenres();
        if (genres != null) {
            for (TVGridType.Event.Genres.Genre genre : genres.getGenreArray()) {
                Long programContentGenreId = getProgramContentGenreId(ctx, genre);
                if (programContentGenreId != null) {
                    CommonDAO.mergeIntoObjectLink(ctx.getSession(), "PROGRAMINPROGRAMCONTENTGENRE", programContentGenreId, programId);
                }
            }
        }

        // добавляем теги к программе
        TVGridType.Event.Tags tags = event.getTags();
        if (tags != null) {
            for (TVGridType.Event.Tags.Tag tag : tags.getTagArray()) {
                Long tagId = getTag(ctx, tag);
                if (tagId != null) {
                    CommonDAO.mergeIntoObjectLink(ctx.getSession(), "CONTENTINTAG", tagId, programId);
                }
            }
        }
    }


    // обрабатываем сохранение урл картинки - чтобы потом заэкспортить можно было
    private void saveImagesUrl(ExecutionContext ctx, Channel c, TVGridType.Event e, long programId) throws Exception {

        if (Boolean.valueOf(ParamHelper.getStringParam(currentParams, "import.epg.channel.save_images_url", "false"))
            && (!EPG_BARKER_TYPE.equals(c.getEpgType())/*!c.isBarker*/)) { // у баркера картинок нет
            

            // тут если увеличивать TASK_IMPORT_LOGO.URL под 16 картинок мы офигеем. Поэтмоу надо как в ЕК метаконтенте - перевести в экспорте епг картинки с диска с генерацией внутреннего урла

            // Итого делваем так - если длина списка урлов слишком велика - то не сохраняем/удаляем её из привязки
            // в итоге там где хотят сохранить кучу картинок - не будет сохранены в TASK_IMPORT_LOGO.
            // Это грозит тем что в экспорте вернется пустота. Но много картинок планируется пока только в MOYO - а там мы сделаем настройку префикса урла и будем её отдавать
            // В других проектах по 1 картинке грузят. Если понадобится несколько - то мы там добавим настройку тоже

            String logoUrls = e.getGate().getImage();
            if (logoUrls != null && logoUrls.length() > 250) { // TASK_IMPORT_LOGO.URL	VARCHAR2(255 BYTE)
                logoUrls = ""; // если не умещается - то очищаем
            }

            ctx.getSession().executeNPPSUpdate(
                    mergeTaskImportLogo,
                    set(
                            bind("ID", programId),
                            new StringParameterBinding("DISCR", "EPGSTOREIMAGE"),
                            new StringParameterBinding("URL", logoUrls)
                    ));

            ctx.getSession().executeNPPSUpdate(
                    mergeTaskImportLogo,
                    set(
                            bind("ID", programId),
                            new StringParameterBinding("DISCR", "EPGSTOREBANNER"),
                            new StringParameterBinding("URL", e.getGate().getBanner())
                    ));
        }
    }


    /**
     * получение уровнядоступа.
     */
    private Long getAccessLevelId(ExecutionContext ctx, TVGridType.Event.Gate.PG pg) throws Exception {
        Long id;
        if (pg == null) {
            return minAccessLevel;
        }
        try {
            id = accessLevelCache.getCached(pg.getSn(), new CacheReader<String, Long>() {
                @Override
                public Long read(String s) throws Exception {
                    return CommonDAO.getIdFromTableByName(ctx.getSession(), "DICTIONARY", "ACCESSLEVELDICTIONARY", s);
                }
            });
        } catch (EntityNotFoundException e) {
            log.error(e.getMessage());
            return minAccessLevel;
        }

        return id;
    }

    private int getIsChild(TVGridType.Event.Gate.PG pg) {
        int isChild = 0;
        if (pg == null || pg.getSn() == null || pg.getSn().length() < 2) {
            return isChild;
        }
        String accessLevel = pg.getSn().substring(0, pg.getSn().length() - 1);
        try {
            if (Integer.parseInt(accessLevel) <= 12) {
                isChild = 1;
            }
        } catch (NumberFormatException nex) {
            log.error(nex.getMessage());
            return isChild;
        }
        return isChild;
    }

    private static String getDirector(HumansType humans) {
        return getHumans(humans, 380, 2);
    }

    private static String getActors(HumansType humans) {
        return getHumans(humans, 1000, 1);
    }

    private static String getScreenplay(HumansType humans) {
        return getHumans(humans, 380, 3);
    }

    private static String getOperator(HumansType humans) {
        return getHumans(humans, 380, 30);
    }

    private static String getComposer(HumansType humans) {
        return getHumans(humans, 380, 31);
    }

    private static String getProducer(HumansType humans) {
        // Продюсеры (Human > Amplois > ID = 4)
        // Продюсер (Human > Amplois > ID = 16)
        return getHumans(humans, 380, 4, 16);
    }

    private static String getHost(HumansType humans) {
        return getHumans(humans, 380, 12);
    }

    private static String getHumans(HumansType humans, Integer maxLength, long... amploiIds) {
        if (humans == null) {
            return "";
        }
        Map<String, StringBuilder> humansStrLangMap = new TreeMap<String, StringBuilder>();
        StringBuilder humansStr = new StringBuilder();
        int i = 0;
        // todo в перспективе лучше переписать (вызовы - один или два элемента, создание новой коллекции - оверхед)
        Set<Long> ids = Arrays.stream(amploiIds)
                .boxed()
                .collect(Collectors.toCollection(HashSet::new));

        while (i < humans.getHumanArray().length) {
            HumansType.Human h = humans.getHumanArray()[i];
            if (ids.contains(h.getAmplois().getID())) { // ТОЛЬКО актеры! (ID=1) или режиссеры или ...
                String name = h.getName();
                if (name != null) {

                    /*
                    humans.removeHuman(i); // не удаляем - пусть лучше каждый раз пробегается по всем Humans. Иначе напр. для 2х каналов с одним extrnalId - для одного актеры зальются, а для другого будет пусто (т.к. TvGrid у них один)
                    continue;
                    */

                    // если мультиязычность - то "@@ru=Коля@@en=Kolya,@@ru=Дима@@en=Dima,@@ru=Ваня@@en=Vanya"    ТРАНСФОРМИРУЕМ В      "@@ru=Коля,Дима,Ваня@@en=Kolya,Dima,Vanya"    (SRVTUBE-3428, https://support.smartlabs.tv/browse/OPTIMA-159  )
                    if (name.indexOf("@@") != -1) {
                        List<String> langParts = CollectionsHelper.convertStringToList(name, "@@", true);
                        for (String langPart : langParts) {
                            //List<String> ts = CollectionsHelper.convertStringToList(langPart, "=", true);
                            int ii = langPart.indexOf('=');
                            //if (ii == -1) throw new Exception("language validation error");
                            //if (!langs.contains(lang)) throw new Exception("language validation error. Language (" + lang + ") not found ");
                            String lang = langPart.substring(0, ii).trim();
                            String localizedName = langPart.substring(ii + 1).trim();

                            StringBuilder humansStrLocal = humansStrLangMap.get(lang);
                            if (humansStrLocal == null) {
                                humansStrLocal = new StringBuilder();
                                humansStrLangMap.put(lang, humansStrLocal);
                            }
                            humansStrLocal.append(localizedName).append(", ");
                        }
                    } else {
                        humansStr.append(name).append(", ");
                    }

                    // break; // Из-за угрозы мультиязычности берем только 1-й список авторов/режиссеров/сценаристов/ит.д..  (Иначе получится "@@ru=Коля@@en=Kolya,@@ru=Дима@@en=Dima,@@ru=Ваня@@en=Vanya", а надо   "@@ru=Коля,Дима,Ваня@@en=Kolya,Dima,Vanya" )
                }
            }
            i++;
        }

        String res;
        if (!humansStrLangMap.isEmpty()) {
            StringBuilder resBuilder = new StringBuilder();
            for (Map.Entry<String, StringBuilder> entry : humansStrLangMap.entrySet()) {
                resBuilder.append("@@" + entry.getKey() + "=" + limitHuman(entry.getValue().toString(), maxLength));
            }
            res = resBuilder.toString();
        } else {
            res = limitHuman(humansStr.toString(), maxLength);
        }

        return res;
    }

    private static String limitHuman(String res, Integer maxLength) {
        if (maxLength != null && res.length() > maxLength) {
            res = res.substring(0, maxLength); // 380 = 764 / 2    
        }
        if (res.endsWith(", ")) {
            res = res.substring(0, res.length() - 2);
        } else if (res.endsWith(",")) {
            res = res.substring(0, res.length() - 1);
        }
        return res;
    }

    private Long getProgramGenreId(ExecutionContext ctx, TVGridType.Event.Flag flag) throws Exception {
        if (flag == null) {
            return null;
        }
        return getProgramGenreId(ctx, flag.getName());
    }

    private Long getProgramGenreId(ExecutionContext ctx, String name) throws Exception {
        if (name == null || name.isEmpty()) {
            return null;
        }
        Long id;
        try {
            id = programGenreCache.getCached(name, new CacheReader<String, Long>() {
                @Override
                public Long read(String s) throws Exception {
                    return getDictIdByExtIdIgnoreCase(ctx, "PROGRAMGENRE", s);
                }
            });
        } catch (EntityNotFoundException e) {
            log.error(e.getMessage());
            id = addNameAndExternalIdToTableWithSortOrder(ctx.getSession(), "DICTIONARY", "PROGRAMGENRE", name, name);
            programGenreCache.put(name, id);
            log.debug("generate new genre ID");
        }
        return id;
    }

    private Long getProgramContentGenreId(ExecutionContext ctx, TVGridType.Event.Genres.Genre genre) throws Exception {
        if (genre == null || genre.getName() == null) {
            return null;
        }
        return getProgramContentGenreId(ctx, genre.getName());
    }

    private Long getProgramContentGenreId(ExecutionContext ctx, String name) throws Exception {
        if (name == null || name.isEmpty()) {
            return null;
        }
        Long id;
        try {
            id = programContentGenreCache.getCached(name, new CacheReader<String, Long>() {
                @Override
                public Long read(String s) throws Exception {
                    return getDictIdByExtIdIgnoreCase(ctx, "PROGRAMCONTENTGENRE", s);
                }
            });
        } catch (EntityNotFoundException e) {
            log.error(e.getMessage());
            id = addNameAndExternalIdToTableWithSortOrder(ctx.getSession(), "DICTIONARY", "PROGRAMCONTENTGENRE", name, name);
            programContentGenreCache.put(name, id);
            log.debug("generate new genre ID");
        }
        return id;
    }

    private Long getProgramCategoryId(ExecutionContext ctx, TVGridType.Event.Categories.Category category) throws Exception {
        if (category == null || category.getName() == null) {
            return null;
        }
        return getProgramCategoryId(ctx, category.getName());
    }

    private Long getProgramCategoryId(ExecutionContext ctx, String name) throws Exception {
        if (name == null || name.isEmpty()) {
            return null;
        }
        Long id;
        try {
            id = categoryCache.getCached(name, new CacheReader<String, Long>() {
                @Override
                public Long read(String s) throws Exception {
                    return getDictIdByExtIdIgnoreCase(ctx, "PROGRAMCATEGORY", s);
                }
            });
        } catch (EntityNotFoundException e) {
            log.error(e.getMessage());
            id = addNameAndExternalIdToTableWithSortOrder(ctx.getSession(), "DICTIONARY", "PROGRAMCATEGORY", name, name);
            categoryCache.put(name, id);
            log.debug("generate new category ID");
        }
        return id;
    }

    private Long getTag(ExecutionContext ctx, TVGridType.Event.Tags.Tag tag) throws Exception {
        if (tag == null || tag.getName() == null) {
            return null;
        }
        return getTag(ctx, tag.getName());
    }

    private Long getTag(ExecutionContext ctx, String name) throws Exception {
        if (name == null || name.isEmpty()) {
            return null;
        }
        Long id;
        try {
            id = tagCache.getCached(name, new CacheReader<String, Long>() {
                @Override
                public Long read(String s) throws Exception {
                    return getDictIdByExtIdIgnoreCase(ctx, "CONTENTTAG", s);
                }
            });
        } catch (EntityNotFoundException e) {
            log.error(e.getMessage());
            id = addNameAndExternalIdToTableWithSortOrder(ctx.getSession(), "DICTIONARY", "CONTENTTAG", name, name);
            tagCache.put(name, id);
            log.debug("generate new tag ID");
        }
        return id;
    }

    /**
     * привязывваем или создаём страну.
     *
     * @param ctx
     * @throws Exception
     */
    private Long getCountryId(ExecutionContext ctx, String country) throws Exception {

        if (country == null) {
            return null;
        }
        long id;
        try {
            id = countryCache.getCached(country, new CacheReader<String, Long>() {
                @Override
                public Long read(String s) throws Exception {
                    return getDictIdByExtIdIgnoreCase(ctx, "COUNTRYDICTIONARY", s);
                }
            });
        } catch (EntityNotFoundException e) {
            log.error(e.getMessage());
            id = addNameAndExternalIdToTableWithSortOrder(ctx.getSession(), "DICTIONARY", "COUNTRYDICTIONARY", country, country);
            countryCache.put(country, id);
            log.debug("generate new country ID");
        }
        return id;
    }

    /**
     * Найти ID в DICTIONARY по дискриминатору по внешнему ключу.
     */
    private static long getDictIdByExtIdIgnoreCase(ExecutionContext ctx, String discriminator, String externalId) throws Exception {
        String sql = "SELECT id\n" +
                     "    FROM DICTIONARY d\n" +
                     "    WHERE d.DISCRIMINATOR = :D AND UPPER(d.EXTERNALID) = UPPER(:EXT)\n" +
                     "    ORDER BY d.ID";
        List<List<String>> foo = ctx.getSession().executeQuery(sql,
                bind("D", discriminator.toUpperCase()),
                bind("EXT", externalId));
        if (foo.size() < 2) {
            throw new EntityNotFoundException("Entity " + discriminator + " with " + "EXTERNALID" + " = " + externalId + " not found");
        }
        return Long.parseLong(foo.get(1).get(0));
    }

    /**
     * Обрабатывает картинку для возможной будущей загрузки
     *
     * @return возвращает обертку картинки (существующей или еще требующей загрузки)
     */
    private ImageWrapper processImg(TVGridType.Event event, String imgUrl, String name) {
        if (log.isDebugEnabled()) {
            log.debug("[ENTER] loadImg [imgUrl=" + imgUrl + "]");
        }
        if (imgUrl == null || imgUrl.isEmpty()) {
            return new ImageWrapper();
        }

        // какое бы имя файла(name) мы не указали извне - если картинка уже загружена текущим процессом то вернется имя загруженного ранее файла
        String alreadyLoaded = imagesLoadedCache.get(imgUrl.trim());
        if (alreadyLoaded != null /*&& !alreadyLoaded.isEmpty()*/) {
            if (log.isInfoEnabled()) {
                String fmtStr = "image already loaded. Get fileName from imagesLoadedCache : url = %s, fileName = %s ";
                log.info(String.format(fmtStr, imgUrl, alreadyLoaded));
            }
            return new ImageWrapper(alreadyLoaded);  // если empty - значит неудачно прошлая попытка, повторно не пробуем грузить
        }


        try {
            ImageWrapper imageWrapper = new ImageWrapper(name);
            // параметр, означающий - сохранена ли уже картинка во время валидации или нет
            boolean saveImageOnValidation = Boolean.valueOf(ParamHelper.getStringParam(currentParams, "saveImageOnValidation", "false"));
            if (!saveImageOnValidation) {
                String designator = ConfigurationHelper.getProperty("program.designator.logo", "program");

                // если скриншот уже лежит на диске (screenShotUrl.toUpperCase().startsWith(toSDPPicturesURL.toUpperCase())) - то забираем его имя и ничего не делаем
                String existingFileName = ExcelImportExportHelper.findAndLoadExistingImage(imgUrl, converterContext, designator);
                if (existingFileName != null && !existingFileName.isEmpty()) {
                    imagesLoadedCache.put(imgUrl.trim(), existingFileName);
                    return new ImageWrapper(existingFileName);
                }
                //String existingFileName = checkUrlOfExistingImage(imgUrl, toSDPPicturesURL);

                imageWrapper.imgUrl = imgUrl;
                imageWrapper.startDate = FORMAT_EVENT.parse(event.getStart());
                imageWrapper.finishDate = FORMAT_EVENT.parse(event.getFinish());
                imageWrapper.designator = designator;
                imageWrapper.needLoad = true; // отсрочили загрузку, на момент после создания контента
            }
            imagesLoadedCache.put(imgUrl.trim(), name);
            return imageWrapper;
        } catch (Exception ex) {
            log.error("Can't load image", ex);
            imagesLoadedCache.put(imgUrl.trim(), "");
            return new ImageWrapper();
        }
    }

    void loadImg(ExecutionContext ctx, ImageWrapper imageWrapper) throws Exception {
        // проверяем режим загрузки картинок (online или offline)
        String loadModeFromParams = ParamHelper.getStringParam(currentParams, "import.epg.logo", null);
        String loadModeFromMiaso = ConfigurationHelper.getProperty("import.epg.logo", "online");
        String loadMode = (loadModeFromParams == null) ? loadModeFromMiaso : loadModeFromParams;
        if (loadMode.equals("online")) {
            // если online - грузим картинку по старинке - сразу
            byte[] data = stvEpgHttpClientForPictures.get(imageWrapper.imgUrl);
            UploadServlet.process(data, imageWrapper.logo, imageWrapper.designator);
            contentServiceFactory.apply(ctx).calculateAndUpdateBgColorIfEmpty(imageWrapper.contentId);
        } else {
            // иначе, если offline, заносим заявку на загрузку картинки в таблицу TASK_IMPORT_LOGO,
            // чтобы загрузить позже отдельным процессом
            int retryCount = Integer.parseInt(ConfigurationHelper.getProperty("import.epg.logo.retry.count", "5"));
            ctx.getSession().executeNPPSUpdate(insertTaskImportLogo,
                    set(
                            new StringParameterBinding("LOGO", imageWrapper.logo),
                            new StringParameterBinding("URL", imageWrapper.imgUrl),
                            bind("CNT", retryCount),
                            new StringParameterBinding("DSC", null),
                            new StringParameterBinding("DESIGNATOR", imageWrapper.designator),
                            new DateTimeParameterBinding("START_DATE", imageWrapper.startDate),
                            new DateTimeParameterBinding("STOP_DATE", imageWrapper.finishDate),
                            new StringParameterBinding("CONTENT_ID", imageWrapper.contentId)
                    ));
        }
    }

    private static boolean isXmlLongNull(XmlLong xmlLong) {
        return (xmlLong == null || xmlLong.xmlText().equals("<xml-fragment/>"));
    }

}
```
</details>

Имеется класс на 2000 строк, который отвечает за получение и парсинг программы передач. Его проблема в том, что все процессы свалены в кучу, из-за этого класс довольно большой. 
Его очень тяжело читать и тестировать. Здесь нужно разделить логику и разнести по разным классам, чтобы каждый занимался своей частью.
Подобные проблемы могут возникать когда разработчики не думают о разделении ответственности, быстро добавляют похожий функционал в класс. 

##### Класс слишком маленький или делает слишком мало.
<details>
<summary>Код</summary>

```java
public class HostnameUtils {
    @Getter
    private static String hostname;

    static {
        try {
            hostname = InetAddress.getLocalHost().getHostName();
        } catch (UnknownHostException e) {
            hostname = "unknown-host";
        }
    }

}
```
</details>

Кажется, про этот класс можно сказать, что он делает слишком мало. К тому же в коде есть всего лишь одно место, где он применяется.
Думаю, что наиболее частая причина этой проблемы -- желание подготовиться к будущему росту/усложнению.  
Выделяется какой-то функционал в отдельный класс, в надежде, что потом туда добавится что-то ещё, но это "ещё" так и не добавляется.
Это похоже на преждевременную оптимизацию.

##### В классе есть метод, который выглядит более подходящим для другого класса.
<details>
<summary>Код</summary>

```java
public class ElkServiceImpl implements ElkService {

    private final ServiceUsageService service;

    @Override
    public List<PurchaseElk> processListPurchaseElk(ExecutionContext ctx, ListPurchasedElkParamSet params) {
        ...
    }

    /**
     * Преобразовать строку в длинное целое число. В случае ошибки преобразования вернуть ноль
     */
    private long toLongDefaultZero(String stringValue) {
        long result;
        try {
            result = Long.parseLong(stringValue);
        } catch (Exception e) {
            log.debug("Can not parse string <{}> as long", stringValue, e);
            result = 0;
        }
        return result;
    }

    private PurchaseElk getPurchaseWithNullStopDateForEst(PurchaseElk p) {
        ...
    }

    /**
     * Вернуть дату и время из параметра.
     * Если параметр не задан, то вернуть значение по умолчанию.
     * Если параметр задан и его значение распознать не удалось, то бросить исключение
     */
    public static Date getDateTimeParam(Map<String, String> params, String paramName, Date defaultValue) {
        Date result;
        String stringValue = params.get(paramName);
        if (stringValue == null) {
            result = defaultValue;
        } else {
            DateTimeHelper dateTimeHelper = DateTimeHelper.getInstance();
            try {
                result = dateTimeHelper.parseDate(stringValue);
            } catch (Exception e) {
                /*
                Ожидаемый формат извлечен из net.comp.core.helpers.DateTimeHelper
                Пришлось изучить исходный код класса (а не только интерфейс),
                иначе неясно, как сообщить пользователю ожидаемый формат даты и времени
                 */
                String expectedFormat = ConfigurationHelper.getProperty(ConfigurationHelper.FORMAT_DATE_INCOMING);
                throw new IllegalArgumentException("Can not parse parameter <" + paramName + ">" +
                                                   " value <" + stringValue + ">" +
                                                   ". Expected value format is <" + expectedFormat + ">", e);
            }
            // Для надежности проверяем корректность преобразования обратным преобразованием
            String revertResult = dateTimeHelper.formatIncomeDate(result);
            if (!stringValue.equals(revertResult)) {
                throw new IllegalArgumentException("Incorrect parameter <" + paramName + "> value" +
                                ". <" + stringValue + "> was incorrectly parsed as <" + revertResult + ">");
            }
        }
        return result;
    }
}
```
</details>

Класс должен содержать методы, которые выводят данные для личного кабинета(в его интерфейсе содержится всего один метод). 
Однако тут есть метод getDateTimeParam, который довольно сильно выбивается по смыслу и его хочется перенести в какой-нибудь утильный класс.
Интересно и то, что этот метод даже не применяется в этом классе.
Кажется, что такие проблемы могут происходить из-за нежелания разработчика создавать отдельный класс для какого-либо метода. 
Проще воткнуть метод в имеющийся класс, с которым ты сейчас работаешь, чем думать над новым названием для класса, его местоположением и т.д.

##### Класс хранит данные, которые загоняются в него в множестве разных мест в программе.
<details>
<summary>Код</summary>

```java
public class ExecutionContext implements AutoCloseable {

    private DataModel model;
    private final Session session;

    @Setter
    private HttpServletRequest request;
    @Setter
    private HttpServletResponse response;
    @Setter
    private Entity entity;

    // В это поле В ParserServlet-е вставляются параметры, пришедшие из непосредственно из HTTP запроса
    private Map<String, String> params = new HashMap<>();

    // Будет использоваться для передачи различных флагов и другой информации при вызове одной команды из другой
    private Map<String, String> ctrlParams = new HashMap<>();

    @Setter
    private Object delegateCommand; // будет использоваться если наследование не спасает

    // будет использоваться чтоб передать какаю-либо важную инфу в команду, чтоб изменить ход выполнения команды или дать рекомендации
    // не придумал ничего лучше для того чтобы передать форматированную(не строковую) инфу в команду
    @Setter
    private Object helpObject;

    public ExecutionContext() {
        this.session = DSProvider.getSession();
    }

    public ExecutionContext(ExecutionContext ctx) {
        initFromAnother(ctx);
        this.session = DSProvider.getSession();
    }
    ...
}
```
</details>
 
Класс является контекстом выполнения команды и он доступен во множестве мест, в рамках обработки того или иного запроса. 
Есть общая точка, где инициализируется объект этого класса, но также в коде встречаются места, где этот класс дополняется теми или иными данными.
Кажется такое получается, когда разработчику нужен способ для передачи данных между слоями, и чтобы сильно не заморачиваться он создаёт здоровую структуру, которую потом наполняет данными во множестве разных мест.
А это приводит к беспорядку и сложностям в сопровождении.

##### Класс зависит от деталей реализации других классов.
<details>
<summary>Код</summary>

```java
@AllArgsConstructor
@Data
public class V8Engine {
    private int power;
    //other fields
}

@AllArgsConstructor
@Data
public class SixSpeedGearBox {
    private int currentGear;
    //other fields
}

@AllArgsConstructor
@Data
public class SportCar {

    private V8Engine engine;
    
    private SixSpeedGearBox gearBox;
    
    //methods
}
```
</details>

Класс может знать о внутренней реализации методов, закладываться на неё, из-за чего высока вероятность возникновения проблем при изменении деталей реализации. Тут стоить использовать абстракции и внедрение зависимостей.
Кажется, что проблемы подобного рода возникают из-за того, что разработчик плохо продумывает иерархию классов.


##### Приведение типов вниз по иерархии (родительские классы приводятся к дочерним).
<details>
<summary>Код</summary>

```java
class Parent { ... }

class Child extends Parent { ... }

public class Main {
    public static void main(String[] args) {
        Parent parent = new Child();
        if (parent instanceof Child) {
            Child child = (Child) parent; 
            // вызываем методы специфичные для класса Child 
        }
    }
}
```
</details>

Даункастинг используют когда нужно использовать метод или поле, имеющиеся лишь в классе наследнике. Операция опасная, так как в ряде случаев об ошибке мы узнаем лишь в рантайме. 
По-хорошему такое делать не стоит, если возникла необходимость в даункастинге, то это признак проблем с дизайном кода.

##### Когда создаётся класс-наследник для какого-то класса, приходится создавать классы-наследники и для некоторых других классов.
<details>
<summary>Код</summary>

```java
abstract class Sportsman { 
    abstract String getGoal(); 
}

class Footballer extends Sportsman { 
    public String getGoal() {
        return new FootballerGoal().get();
    } 
}
class Runner extends Sportsman {
    public String getGoal() {
        return new RunnerGoal().get(); 
    } 
}

abstract class Goal {
    public abstract String get();
}

public class FootballerGoal extends Goal {
    public String get() {
        return "Score 1 goal";
    }
}

public class RunnerGoal extends Goal {
    public String get() {
        return "Run 1 km";
    }
}
```
</details>

В коде приведена ситуация, когда при создании наследника класса Sportsman придётся создавать наследника класса Goal. В жизни такое не встречал (к счастью). 
Нашёл информацию, что такую проблему могут называть как Parallel Inheritance Hierarchies. Кажется, что проблема может возникнуть из-за желания разработчика создать свой интерфейс чуть ли не для каждой функции.
Как будто бы тут тоже прослеживается проблема преждевременной оптимизации.

##### Дочерние классы не используют методы и атрибуты родительских классов, или переопределяют родительские методы.
<details>
<summary>Код</summary>

```java
class Bird {
    public void fly() {
        System.out.println("Flying");
    }
}

class Penguin extends Bird {
    @Override
    public void fly() {
        throw new UnsupportedOperationException("Penguins can't fly");
    }
}
```
</details>

Синтетический пример, где отражена такая ситуация. Такие ситуации могут происходить когда разработчик решил, что лучше сначала сесть и что-то написать, а не подумать.
Не продумали иерархию классов, какие-то ключевые моменты важные для конкретного проекта и получаем такую проблему. Также она может проявиться при попытке 
создать большой базовый класс со множеством методов и полей, которые на данный момент не нужны. (Опять преждевременная оптимизация и решение проблем, которых ещё нет) 

##### Одна модификация требует внесения изменений в несколько классов.
<details>
<summary>Код</summary>

```java
@Data
public class User {
    private String email;
}

public class UserValidator {
    public boolean validate(User user) {
        String email = user.getEmail();
        return email != null && email.contains("@") && email.endsWith(".com");
    }
}

public class UserNotifier {
    public void notifyUser(User user) {
        String email = user.getEmail();
        System.out.println("Отправка уведомления на: " + email);
        //логика 
    }
}

public class UserLogger {
    public void logUser(User user) {
        String email = user.getEmail();
        System.out.println("Логирование: Email пользователя - " + email);
        //логика 
    }
}

public class Main {
    public static void main(String[] args) {
        User user = new User();
        user.setEmail("user@example.com");

        UserValidator validator = new UserValidator();
        boolean isValid = validator.validate(user); 
        System.out.println("Пользователь валиден: " + isValid);

        UserNotifier notifier = new UserNotifier();
        notifier.notifyUser(user); 

        UserLogger logger = new UserLogger();
        logger.logUser(user);
    }
}
```
</details>
Если мы захотим поменять тип данных поля email, например на какой-то кастомный, то придётся вносить правки в ещё три класса, так как они заложились на детали реализации класса User.
Проблема может возникать когда одни модули знают многое о других, либо когда логика размазывается по проекту, или когда какая-то часть копипастится из одного места в другое, а потом в третье и т.д.

##### Использование сложных паттернов проектирования там, где можно использовать более простой и незамысловатый дизайн.
<details>
<summary>Код</summary>

```java
public enum ServiceProviderValidatorFactory {
    INSTANCE;

    private final Function<Session, ProviderDao> providerDaoFactory = ProviderDbDao::new;

    /**
     * Возвращает валидатор для провайдера.
     *
     * @param ctx контекст
     * @param accNumber номер учётной записи
     * @return валидатор для оператора
     */
    public Validator<String> createValidator(ExecutionContext ctx, String accNumber) {
        return new ProviderValidator(() -> providerDaoFactory.apply(ctx.getSession()).getByAccountNumber(accNumber));
    }
}
```
</details>

Здесь используется фабрика для создания валидатора, но по большому счёту у нас тут нет разных вариантов реализации. В валидаторе проверяется дто с данными провайдера, который достаётся из БД по номеру учётки.
Кажется, что в этом случае ничего не мешает отказаться от фабрики и сразу использовать валидатор. Скорее всего раньше тут были какие-то варианты, но при рефакторинге и упрощении кода от фабрики почему-то не отказались. 
В общем случае проблемы подобного рода возникают из-за преждевременных оптимизаций, когда разработчик закладывается на будущее или решает проблемы, которых ещё нет. А возможно разработчик только прочитал про паттерны и хочет везде их применять.  

##### Выводы
В этом занятии мы посмотрели разные примеры плохого дизайна кода на уровне классов и приложения. Отчасти эти проблемы проявляются из-за преждевременной оптимизации и решения проблем, которых ещё нет.
Часть проблем возникает из-за того, что разработчик не думает над дизайном какое-то время, а сразу бросается писать код. Какие-то проблемы могут проявиться из-за спешки или лени.
Чтобы всего этого избежать следует думать, прежде чем писать код, не спешить с разными оптимизациями, а решать проблемы по мере их поступления. Ну и нужно не лениться, а делать как надо, а не как проще, ибо потом "как проще" может порядочно усложнить жизнь. 