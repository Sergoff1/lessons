### Пример 1
<details>
<summary>До</summary>

```java
...
@Cacheable("networkTypes")
public List<NetworkType> getNetworkTypes(Mrf mrf) {
    log.info("Start getNetworkTypes({})", mrf);
    return someClient.getNetworkTypesDict(mrf);
}
...

@Getter
@Setter
public class NetworkType {

    private Long id;
    private Long internalId;
    private String mrf;
    private String externalId;
    private String name;
    private String description;

}
```
</details>

<details>
<summary>После</summary>

```java
...
@Cacheable("networkTypes")
public List<NetworkType> getNetworkTypes(Mrf mrf) {
    log.info("Start getNetworkTypes({})", mrf);
    return someClient.getNetworkTypesDict(mrf);
}
...

public record NetworkType(Long id,
                          Long internalId,
                          String mrf,
                          String externalId,
                          String name,
                          String description) {
}
```
</details>

В одном из приложений используется кэш, в нём хранится коллекция мутабельных объектов. Получаем ситуацию, когда объект, после получения из кэша, можно изменить. 
Это может привести к различным побочным эффектам, которые будут крайне нежелательны, плюс затруднится отладка.
В результате правок, в кэше теперь хранится коллекция иммутабельных объектов. Код стал безопаснее и надёжнее, так как с объектами из кэша можно работать без страха испортить сам кэш.

### Пример 2
<details>
<summary>До</summary>

```java
@Getter
@Setter
@Builder
public class CardDto {
    private String cardId;
    private String cardType;
    private String cardNum;
    private String bankName;
    private String activeCard;
    private String defaultCard;
    private String phoneNum;
    private String authCard;
    private String systemReg;
    private String cardRegisterTime;
}
```
</details>

<details>
<summary>После</summary>

```java
@Getter
@Builder
public class CardDto {
    private final String cardId;
    private final String cardType;
    private final String cardNum;
    private final String bankName;
    private final String activeCard;
    private final String defaultCard;
    private final String phoneNum;
    private final String authCard;
    private final String systemReg;
    private final String cardRegisterTime;
}
```
</details>

Сделали структуру данных с информацией о карте иммутабельной, убрали сеттеры. 
Теперь можно быть уверенным в том, что значения в структуре не поменяются в процессе работы методов.
В итоге в коде программы стало меньше точек, где программист может что-то перепутать и сломать.

### Пример 3
<details>
<summary>До</summary>

```java
class Order {
    private long id;
    private String status;
    private LocalDateTime updatedAt;

    public void updateStatus(String status) {
        this.status = status;
        this.updatedAt = LocalDateTime.now();
    }
}
```
</details>

<details>
<summary>После</summary>

```java
record Order(long id, String status, LocalDateTime updatedAt) {
}

class OrderHistory {
    private final List<Order> history = new ArrayList<>();

    public void updateStatus(long id, String status) {
        history.add(new Order(id, status, LocalDateTime.now()));
    }

    public List<Order> getHistory() {
        return new ArrayList<>(history);
    }
}
```
</details>

Синтетический пример. Есть заказ, мы можем обновлять его статус. В изначальной версии изменение статуса меняет объект заказа. 
В новой объекты заказа стали неизменяемыми, теперь каждое изменение создаёт новый заказ с новым статусом, а предыдущие состояния сохраняются. Получаем историю изменений заказа.

### Выводы
Пока делал это задание, я столько раз перечитал учебный материал, что стал ощущать, будто хорошо понял его, по крайней мере некоторые аспекты. Заодно вспомнил почему в Джаве всё всегда передаётся по значению.  
Вообще приведённые примеры я считаю не очень удачными, так как ни в одном я не вижу ощутимого упрощения кода.   
Пересмотрел свои проекты и почти везде вижу попытки работать с иммутабельностью. То есть у нас изначально всё пытаются сделать через иммутабельные объекты. 
Да и специфика проектов такова, что каких-то сложных сценариев работы с объектами, где могли бы хорошо раскрыться вещи, о которых говорилось в материале, у нас как будто нет.  
Что вообще понял, какие мысли останутся со мной после выполнения этого задания:  
Мутабельность это не плохо и её вполне можно использовать, но нам нужна хорошая модель данных, при которой мутабельность не обернётся бедой.  
Мутабельность приносит сложность, дополнительное состояние(объекты равны или объекты просто имеют одинаковые значения?), тогда как в иммутабельном мире у нас как будто бы возникает меньше вопросов к объектам. 
В результате при использовании мутабельности нужно больше напрягаться, чтобы всё учесть и не получить нежелательные побочные эффекты.
Кажется, что всё это особенно проявляется, когда мутабельный объект может использоваться в нескольких местах (в разных объектах). Мы вроде и можем работать с мутабельность, но тогда нам нужно добавлять какие-то проверки и правила, которые позволят нам избежать нежелательных последствий. А это усложняет системы. 
На этом фоне иммутабельность выглядит стабильнее и безопаснее. В общем случае, нужно стремиться работать с иммутабельными объектами, так как это даёт более предсказуемые результаты
и упрощает размышления о программе.