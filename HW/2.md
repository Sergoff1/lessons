Fuzz-тестирование это такой способ организации тестирования, когда в программу/функцию подаются разнообразные входные данные, как правило, сгенерированные случайно.
Человек часто привязывается к какой-то системе и выдаёт данные в соответствии с этой системой. Фаззер же генерирует рандомные данные и делает это в большом количестве. 
В результате чего могут вскрыться ошибки, которые человек не смог предусмотреть. 

Для выполнения задания я решил использовать Jazzer, так как этот инструмент фаззинга написан специально для языка Java и имеет интеграцию с популярным тестовым фреймворком JUnit. 
По ходу работы выяснил, что Jazzer работает в режиме генерации новых данных и в режиме регресса, когда проверяются сценарии, на ранее сгенерированных данных.
Инструмент оказался удобным, но пришлось покопаться в документации, чтобы найти способы его комфортного применения. На главной странице рассказывается о C-подобном подходе. 
А чуть глубже в документации есть информация о том, как библиотека интегрирована с фреймворком JUnit и как можно конфигурировать тесты с помощью аннотаций. 
Мы можем использовать примитивы и объекты, с которыми привыкли работать в Java-программах. Для этих типов данных можно задавать различные ограничения. 
Например, можно ограничить диапазон значений какого-нибудь числового параметра или запретить null. Однако в документации сказано, что Jazzer будет лишь пытаться удовлетворить заданным ограничениям, и гарантий нет.

Для экспериментов использовал проект на Java. 25 тысяч строк кода (с учётом пустых и комментариев). При этом 10 тысяч строк приходится на язык Python (на нём написаны тесты) и 10 тысяч на Java.
Сначала пытался проверять довольно небольшие части проекта, например какие-нибудь конвертеры. Выявил несколько ошибок. 
Например, какой-то параметр фаззер передал в виде null-значения, где-то не удалось сконвертировать строку в enum, так как значение строки не соответствовало вариантам в enum.
Сделал некоторые фиксы и тесты стали проходить. Для повторной проверки запускал тестирование в режиме регресса.
Потом понял, что тест сделан на низком уровне и спецификацией/контрактом гарантируется, что определённое значение (из-за которого тест падал) обязательно окажется в конвертируемом объекте, просто оно назначается на другом уровне, до вызова конвертера.
Сделал вывод, что нужно грамотнее выбирать тестируемые компоненты и иногда стоит задавать ограничения на генерируемые значения (если это соответствует спецификации).
Затем я сделал тесты с учётом контрактов и ошибок в тестируемых компонентах не обнаружил.   

Сложности:
Нужно грамотно писать тесты, и выбирать места для тестирования иначе можно получать ошибки связанные с тем, что фаззер генерирует данные, которые не должны быть в том или ином месте по спецификации.
Фазз-тесты требует больше времени на своё выполнение. Хорошо, что в Jazzer можно ставить ограничения на время выполнения теста в фаззинг-режиме.
Написание таких тестов заставляет хорошенько подумать и для выполнения задания пришлось изрядно напрячься.

Выводы:
Кажется, что фаззинг очень хорошо подходит для тестирования компонентов, куда приходят данные от пользователя или от каких-то внешних сущностей, с которыми мы не очень хорошо знакомы.
Тесты выполняются долго, писать их сложнее и кажется, что широко такой подход не применяется, однако в ряде случаев он может быть крайне полезен. Так как может помочь отловить ряд непредсказуемых ошибок.