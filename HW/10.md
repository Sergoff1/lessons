##### Пример 1
<details>
<summary>До</summary>

```java
pendingRequestDao.savePendingRequestHistory(pendingRequest.getId(),
PendingRequest.DISCRIMINATOR_BONUS_SUBSCRIPTION_SERVICE_REQUEST,
PendingRequest.RequestState.CANCELED,
        String.format(PendingRequest.MESSAGE_ERROR_BONUS_SUBSCRIPTION_SERVICE_ASYNC_REQUEST,
                      getRequestStatusComment(serviceParams.getStatus(), serviceParams.getMessage())));
```
</details>

<details>
<summary>После</summary>

```java
final String statusComment = String.format(PendingRequest.MESSAGE_ERROR_BONUS_SUBSCRIPTION_SERVICE_ASYNC_REQUEST,
        getRequestStatusComment(serviceParams.getStatus(), serviceParams.getMessage()));
pendingRequestDao.savePendingRequestHistory(pendingRequest.getId(),
PendingRequest.DISCRIMINATOR_BONUS_SUBSCRIPTION_SERVICE_REQUEST,
PendingRequest.RequestState.CANCELED, 
statusComment);
```
</details>

В строке, которая добавляет в БД запись о смене статуса заявки на подключение услуги выполнялось вычисление текста комментария для этой записи.
Вынес логику по формированию комментария в отдельное место. Теперь в изначальной строке выполняется лишь сохранение записи. 

##### Пример 2
<details>
<summary>До</summary>

```java
messageServiceFactory.apply(ctx).sendUnlinkNotification(
                        terminal.getSuperUid(),
                        terminal.getMac(),
                        terminal.getDeviceTypeExtId());
```
</details>

<details>
<summary>После</summary>

```java
MessageService messageService = messageServiceFactory.apply(ctx);
                messageService.sendUnlinkNotification(
                        terminal.getSuperUid(),
                        terminal.getMac(),
                        terminal.getDeviceTypeExtId());
```
</details>

В одной строке получали сервис для отправки сообщений из фабрики и потом выполняли отправку сообщения.
Теперь создание сервиса и отправка сообщения выполняются в разных строках.

##### Пример 3
<details>
<summary>До</summary>

```java
1 StringBuilder columnExpr = new StringBuilder().append(field.getColumnName());
2 fieldSet.append(DBMSHelper.getInstance().getDateToCharExpression(columnExpr.toString(), "HH24:MI:SS")).append(" \"").append(field.getName()).append("\"");
3 return fieldSet.toString();
```
</details>

<details>
<summary>После</summary>

```java
1 StringBuilder columnExpr = new StringBuilder().append(field.getColumnName());
2 String toCharExpression = DBMSHelper.getInstance().getDateToCharExpression(columnExpr.toString(), "HH24:MI:SS");
3 fieldSet.append(toCharExpression).append(" \"").append(field.getName()).append("\"");
4 return fieldSet.toString();
```
</details>

Тут имеется длинная строка(2), в которую пришлось вчитываться, чтобы понять происходящее в ней. Здесь формируется часть SQL-запроса (для SELECT`а), а также выполняется формирование выражения для вызова метода to_char в той или иной БД.
Вынес логику формирования выражения to_char на отдельную строку. В строке 2 сократилось количество вызываемых методов и она стала проще для восприятия.

##### Пример 4
<details>
<summary>До</summary>

```java
addLocalizedField(sb, refEntity, refField, new StringBuilder(refField.getName()).append(".ID").toString(), bindings, joins);
```
</details>

<details>
<summary>После</summary>

```java
String idString = refField.getName() + ".ID";
addLocalizedField(sb, refEntity, refField, idString, bindings, joins);
```
</details>

В одной строке вызывает метод и создаётся объект, который используется в качестве параметра для этого метода.
Вынес создание объекта в другую строку. Теперь в изначальной строке происходит простой вызов метода. 

##### Пример 5
<details>
<summary>До</summary>

```java
bindings.add(new StringParameterBinding(SynonymHelper.limitString(refEntFieldName).toUpperCase(), params.get(fieldName + "." + refEntFieldName)));
```
</details>

<details>
<summary>После</summary>

```java
String fullName = params.get(fieldName + "." + refEntFieldName);
String limitedRefEntFieldName = SynonymHelper.limitString(refEntFieldName).toUpperCase();
bindings.add(new StringParameterBinding(limitedRefEntFieldName, fullName));
```
</details>

В одной строке вызывает много методов и она выглядит громоздко.
Вынес вызов методов в другое место, результаты этих методов записал в переменные, которые применяются в изначальной строке. 
Теперь строку проще воспринимать.

##### Выводы
Строки в которых происходит много действий тяжело читать, из-за чего повышается риск совершить ошибку при работе с кодом. 
Также растёт общее напряжение при чтении такого кода, нужно прикладывать больше усилий, чтобы его понять. Из-за этого остаётся меньше энергии на действительно важные вещи.
По возможности следует стараться писать код так, чтобы каждая строка несла какую-то одну ответственность.