### Пример 1:
<details>
<summary>До</summary>

```java
...
protected void doGet(HttpServletRequest request, HttpServletResponse response)
        throws IOException {
    PrintWriter writer = response.getWriter();
    try {
        writer.println(String.format("Java version: %s", System.getProperty("java.version")));
        ServletContext sc = getServletContext();
        writer.println(String.format("Servlet API version: %s.%s", sc.getMajorVersion(), sc.getMinorVersion()));
        writer.println();
        writer.println("Attributes:");
        Enumeration<String> attrs = sc.getAttributeNames();
        while (attrs.hasMoreElements()) {
            String attr = attrs.nextElement();
            writer.println(String.format("%s = %s", attr, sc.getAttribute(attr)));
        }
        writer.println();
        writer.println("Servlets:");
        for (Map.Entry<String, ? extends ServletRegistration> it : sc.getServletRegistrations().entrySet()) {
            writer.println(String.format("%s:", it.getKey()));
            for (String path : it.getValue().getMappings()) {
                writer.println(String.format("      => %s", path));
            }
        }
    } finally {
        writer.close();
    }
}
...
```
</details>

<details>
<summary>После</summary>

```java
...
    protected void doGet(HttpServletRequest request, HttpServletResponse response)
            throws IOException {
        try (PrintWriter writer = response.getWriter()) {
            writer.println(String.format("Java version: %s", System.getProperty("java.version")));
            ServletContext sc = getServletContext();
            writer.println(String.format("Servlet API version: %s.%s", sc.getMajorVersion(), sc.getMinorVersion()));
            writer.println();
            writer.println("Attributes:");
            Enumeration<String> attrs = sc.getAttributeNames();
            while (attrs.hasMoreElements()) {
                String attr = attrs.nextElement();
                writer.println(String.format("%s = %s", attr, sc.getAttribute(attr)));
            }
            writer.println();
            writer.println("Servlets:");
            for (Map.Entry<String, ? extends ServletRegistration> it : sc.getServletRegistrations().entrySet()) {
                writer.println(String.format("%s:", it.getKey()));
                for (String path : it.getValue().getMappings()) {
                    writer.println(String.format("      => %s", path));
                }
            }
        }
    }
...
```
</details>

Заменили конструкцию `try` на `try-with-resources`, благодаря чему можем отказаться от блока `finally` и избавиться от необходимости думать о закрытии ресурса. 

### Пример 2:
<details>
<summary>До</summary>

```java
...
List<EntityField> fieldList = entity.getFields();
List<String> fieldNames = new ArrayList<String>();

for(EntityField field : fieldList) {
    fieldNames.add(field.getName());
}
...
```
</details>

<details>
<summary>После</summary>

```java
...
List<String> fieldNames = entity.getFields().stream().map(EntityField::getName).toList();
...
```
</details>

Избавились от цикла `for` и промежуточной переменной, использовав Stream API. Сократили код с 5-и строк до 1-й.

### Пример 3:
<details>
<summary>До</summary>

```java
...
private void dispatch(HotezaRequest hotezaRequest, String path, ExecutionContext ctx) {
    if ("/hoteza/checkin".equals(path)) {
        hotezaService.checkIn(ctx, hotezaRequest);
    } else if ("/hoteza/checkout".equals(path)) {
        hotezaService.checkOut(ctx, hotezaRequest);
    } else if ("/hoteza/guestchange".equals(path)) {
        hotezaService.changeGuest(ctx, hotezaRequest);
    } else if ("/hoteza/readmessages".equals(path)) {
        hotezaService.sendMessages(ctx, hotezaRequest);
    } else {
        log.error("Path not found");
        throw new IllegalArgumentException("Path not found");
    }
}
...
```
</details>

<details>
<summary>После</summary>

```java
...
private final BiConsumer<ExecutionContext, HotezaRequest> defaultAction = (context, request) -> {
    log.error("Path not found");
    throw new IllegalArgumentException("Path not found");
};

private final Map<String, BiConsumer<ExecutionContext, HotezaRequest>> pathActions = new HashMap<>();

@Override
public void init() {
    pathActions.put("/hoteza/checkin", (context, request) -> hotezaService.checkIn(context, request));
    pathActions.put("/hoteza/checkout", (context, request) -> hotezaService.checkOut(context, request));
    pathActions.put("/hoteza/guestchange", (context, request) -> hotezaService.changeGuest(context, request));
    pathActions.put("/hoteza/readmessages", (context, request) -> hotezaService.sendMessages(context, request));
    ...
}

private void dispatch(HotezaRequest hotezaRequest, String path, ExecutionContext ctx) {
    pathActions.getOrDefault(path, defaultAction).accept(ctx, hotezaRequest);
}
...
```
</details>

Избавились от конструкции `if-else-if`. Код в методе dispatch сократился до одной строки, снизилась цикломатическая сложность. Вместо множества if-ов используется словарь с функциями,
которые нужно применить для того или иного эндпоинта. Теперь даже не нужно трогать метод dispatch, если нам понадобится добавить/удалить эндпоинт.

### Выводы
Нужно стараться выходить на более высокий уровень абстракции. Это повышает читаемость кода и снижает вероятность совершения ошибок.
Вспомнил свой код и кажется, что у меня он получается относительно компактным, как раз за счёт использования некоторых абстракций(хотя, скорее всего, тут есть куда расти).
С какого-то времени стал всё чаще использовать Stream API, что позволяет писать более выразительный код, без использования циклов и условий.
Также в материалах занятия увидел ряд новых идей (или посмотрел на старые с другой стороны). Кажется, что стал немного лучше понимать смысл и способы абстрагирования.
В ходе выполнения задания понял, что мне трудно выделить чёткое название для той или иной абстракции. Наверное это не очень хорошо, так как понятия, которыми мы мыслим, важны.
И хороший словарный запас (запас понятий) помогает эффективнее размышлять над задачей(как мне кажется). 
Хотя решение в примере номер 3 пришло мне в голову достаточно просто, наверное потому, что я реализовывал нечто подобное в рамках прошлых занятий, и возможно со временем у меня наработается определённый набор понятий для выражения тех или иных абстракций в ходе размышления над решением задачи.

