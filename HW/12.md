### Отказ от точек генерации исключений
Пример 1:
<details>
<summary>До</summary>

```java
 public List<DeviceDto> findDevicesByAccNumAndType(@NonNull String accountNumber, 
                                                   @Nullable String deviceType, 
                                                   @Nullable List<String> deviceTypes) {

    if (deviceType != null && deviceTypes != null) {
        throw new RuntimeException(ONLY_ONE_EXCLUSIVE_PARAM_ACCEPTED_ERROR_MESSAGE);
    }
    ...
}
```
</details>

<details>
<summary>После</summary>

```java
 public List<DeviceDto> findDevicesByAccNumAndType(@NonNull String accountNumber,
                                                   @Nullable List<String> deviceTypes) {
    
    ...
}
```
</details>

Имеется метод поиска устройств, привязанных к учётной записи. У него есть 2 взаимоисключающих параметра, в которых можно задать тип/типы искомых устройств.
Если задать 2 параметра разом, то будет проброшено исключение. В данном случае мы можем поменять интерфейс, избавившись от одного из параметров в этом методе.
Удаляем параметр, который принимает один тип устройства. 
В итоге мы можем получить те же самые данные, но вероятность возникновения ошибки при работе с этим методом стала ниже, так как исчезла одна из точек генерации исключений.
Я удивился когда обнаружил этот метод. Так как проблема и решение слишком очевидны, но оказалось, что так было сделано для сохранения обратной совместимости. 
Раньше в коде был только один параметр.  
Это наталкивает на мысль, что попытки поддерживать обратную совместимость могут быть опасны и приводить к коду, который более подвержен ошибкам.

Пример 2:
<details>
<summary>До</summary>

```java
public ResponseEntity<Account> create(@RequestBody Account newAccount) {
    if (newAccount.getId() != 0) {
        throw new AccountStorageException("Don't specify ID for create method");
    }
    final Account savedAccount = accountRepository.saveAndFlush(newAccount);
    final URI location = ServletUriComponentsBuilder.fromCurrentRequest().path("/{id}")
            .buildAndExpand(savedAccount.getId()).toUri();
    return ResponseEntity.created(location).body(savedAccount);
}
```
</details>

<details>
<summary>После</summary>

```java
public ResponseEntity<Account> create(@RequestBody NewAccountDto newAccountDto) {
    Account newAccount = newAccountDtoToAccountConverter.convert(newAccountDto);
    final Account savedAccount = accountRepository.saveAndFlush(newAccount);
    final URI location = ServletUriComponentsBuilder.fromCurrentRequest().path("/{id}")
            .buildAndExpand(savedAccount.getId()).toUri();
    return ResponseEntity.created(location).body(savedAccount);
}
```
</details>

Есть метод создания учётной записи, который на вход принимает объект типа Account(является моделью БД). 
И перед сохранением нового аккаунта выполняется проверка на то, что пользователь не указывал ID, иначе будет проброшено исключение.
В новой версии изменён тип входного параметра. В нём не используется ID. А после получения этот объект конвертируется в объект типа Account.  
Благодаря этому нет нужды проверять наличие заданного поля ID и пробрасывать соответствующее исключение.

### Отказ от дефолтных конструкторов
Пример 1:
<details>
<summary>До</summary>

```java
@Getter
@ToString
@NoArgsConstructor
@EqualsAndHashCode
public class ReqAnswer {
    /**
     * Статус выполнения запроса.
     */
    private int reqStatus;
    /**
     * Комментарий или сообщение об ошибке. Лимит - 512 символов.
     */
    private String reqNote;

    public ReqAnswer(Integer reqStatus, String reqNote) {
        this.reqStatus = reqStatus;
        this.reqNote = (reqNote != null && reqNote.length() > 512)
                ? reqNote.substring(0, 512)
                : reqNote;
    }
}
```
</details>

<details>
<summary>После</summary>

```java
@Getter
@ToString
@EqualsAndHashCode
public class ReqAnswer {
    /**
     * Статус выполнения запроса.
     */
    private int reqStatus;
    /**
     * Комментарий или сообщение об ошибке. Лимит - 512 символов.
     */
    private String reqNote;

    public ReqAnswer(Integer reqStatus, String reqNote) {
        this.reqStatus = reqStatus;
        this.reqNote = (reqNote != null && reqNote.length() > 512)
                ? reqNote.substring(0, 512)
                : reqNote;
    }
}
```
</details>

В этой структуре передаётся ответ, который не должен быть пустым. На первый взгляд кажется, что тут всё нормально.  
Однако здесь имеется аннотация `@NoArgsConstructor`, которая добавляет конструктор без параметров. Из-за чего есть вероятность создания пустого ответа, чего быть не должно, так как мы обязаны сообщить о статусе выполнения запроса.
Убрал аннотацию `@NoArgsConstructor`, чем запретил создавать пустой объект ReqAnswer. 

Пример 2:
<details>
<summary>До</summary>

```java
public class RegexValidator {

    private List<Pattern> patterns;
    ...
    //validation methods
}
```
</details>

<details>
<summary>После</summary>

```java
public class RegexValidator {

    private final List<Pattern> patterns;

    public RegexValidator(List<Pattern> patterns) {
        this.patterns = patterns;
    }
    ...
    //validation methods
}
```
</details>

Есть класс, который валидирует строку по списку регулярных выражений. Список задаётся через сеттер.
При использовании дефолтного конструктора есть риск забыть проинициализировать список паттернов и валидатор будет в некорректном состоянии.
Перекрываем пустой дефолтный конструктор указав свой, который принимает список паттернов. Теперь пользователь вынужден указывать паттерны для сравнения.
Вероятность ошибок снижена, так как программа даже не запустится, если не передать список паттернов для сравнения.

### Отказ от примитивных типов данных
Пример 1:
<details>
<summary>До</summary>

```java
 public class PurchaseDto {
    ...
    private String status;
    ...
}
```
</details>

<details>
<summary>После</summary>

```java
 public class PurchaseDto {
    ...
    private Status status;
    ...
}

public enum Status {
    TEMPORARY,
    CONFIRMED,
    CANCELLED,
    EXCHANGED
}
```
</details>

Имеется структура с информацией о покупке. Одно из полей содержит значение статуса покупки. 
Есть смысл задать статус с помощью перечисления, так как количество статусов ограничено. 
Получаем более наглядный код (теперь без похода в документацию понятно, а какие вообще есть статусы), также снижается вероятность ошибок, так как пользователь не может указать несуществующий статус.

Пример 2:
<details>
<summary>До</summary>

```java
...
public class Channel {
    ...
    private final String region;
}
```
</details>

<details>
<summary>После</summary>

```java
...
public class Channel {
    ...
    private final Region region;
}

public enum Region {
    STH,
    MOS,
    CT,
    SIB,
    VLG,
    NW,
    URAL,
    DV
}
```
</details>
В описании канала есть поле обозначающее регион, которому он принадлежит. В рамках проекта есть фиксированное число регионов (меньше десятка), с определёнными обозначениями.
В документации, базах данных и коде используются эти обозначения. Есть смысл задавать регион с помощью перечисления, а не строки. 
Опять повышается читаемость кода, благодаря чему условному новичку станет проще погрузиться в контекст. А также снижается вероятность указать некорректный регион.    

### Выводы
Довольно интересные способы облегчения понимания и повышения ошибкоустойчивости системы. Главное их хорошо усвоить и применять на практике.
Было довольно тяжело найти примеры для проблемы с дефолтным конструктором. Почти во всех местах, что я видел, имелись конструкторы с параметрами. 
Хотя есть случаи, когда использование какой-либо технологии заставляет разработчика оставлять дефолтные конструкторы(например JPA или lombok и аннотация builder). 
Однако и тут есть способы ограничить его область видимости.
В целом, показалось, что правило 2 соблюдать легко, а вот с правилами 1 и 3 чуть сложнее (по крайней мере для меня).
Тут уже нужно больше думать и, наверное не торопиться.
Кажется, что очень легко не делать то, о чём говорится в правилах 1 и 3, если ты хочешь фигачить код быстро и не напрягаясь.
Гораздо проще использовать какой-нибудь примитив, чем разработать систему типов. Да и проще бросить исключение, чем сидеть и думать над грамотным интерфейсом.
Однако лучше посидеть и подумать, так как в дальнейшем будет гораздо проще взаимодействовать с проработанной системой, в которой тяжело наделать ошибок.
Соблюдение правил из этого задания не кажется очень сложным, но оно даёт неплохой прирост к устойчивости и читаемости кода. 
Главное не лениться, думать прежде чем писать и, конечно, не забывать об этих правилах.
