#### 1. Зависимость фреймворка
У нас в проекте есть планировщик, который запускает различные задачи, данные о задачах хранятся в БД(какой метод с какими параметрами запустить).
И хотя планировщик вызывает задачи, мне кажется, что он не зависит от этих задач. Раньше я даже не думал об этом в контексте зависимостей.

#### 2. Зависимость расшаренного формата
На работе был случай, когда после рефакторинга наш сервис стал отправлять другому новый параметр в одном из запросов(вроде даже пустой). 
В результате сторонний сервис не мог обработать запрос и возвращал ошибку. Для исправления ситуации мы просто убрали ненужный параметр.
Ну а вообще я видел пост с разбором подобной темы и предложением использовать мерж jsonов, чтобы не зависеть от версий API. 
Заметил тут интересный момент: можно ли в подобных случаях считать отправителя, зависимым от получателя? 
Мне кажется, что это определяется ожиданиями от работы сервисов, от их целей. Если неспособность получателя обработать обновлённый запрос не влияет на отправителя, то отправитель не зависит от получателя.
Но если же она влияет, то отправитель будет зависеть от получателя. Например, мы можем отправить запрос в сторонний сервис и использовать его ответ для дальнейших расчётов. 
Тогда из-за того, что мы поменяем формат запроса, пострадает не только получатель, но и отправитель. 

#### 3. Зависимость зависимости
У нас есть два вроде независимых проекта, для них настроены пайплайны, одним из шагов которых является сборка rpm-пакета с приложением и сохранение этого пакета в специальном репозитории. 
Оба проекта сохраняют свои пакеты в один репозиторий. Долгое время все работало хорошо. Но однажды мы столкнулись с тем, что пайплайн отработал(отмечен зелёными галочками),
но пакета в репозитории не было. Начали разбираться в чём дело и оказалось, что если в двух разных проектах будет запущен этап загрузки пакета в репозиторий примерно в одно время,
то пайплайн, который начал задачу чуть позже не отработает как ожидается(пакет не окажется в репозитории), при чём ошибок он тоже не выдаст. На этом этапе используется пара команд типа rsync.
Для решения проблемы решили просто учитывать эту особенность и не запускать пайплайны по этим двум проектам в одно время.

#### 4. Зависимость краша
В качестве примера тут можно привести репозитории, через которые мы обращаемся к БД из кода. На первый взгляд два репозитория не зависят друг от друга.
Например, один может давать информацию о менеджерах предприятия, а второй о моделях автомобилей предприятия. Они обращаются к разным таблицам, используются в разных сервисах и т.д.
Но по умолчанию Spring Boot используется пул из 10 подключений к БД, и репозитории, чтобы обработать запрос, берут подключения из этого пула.
Получается, если в одном репозитории будут использоваться проблемные запросы(долго выполняются, не отдают подключения), то может пострадать работоспособность другого репозитория,
так как они используют общий пул подключений. Получается, что один репозиторий может повлиять на работу других. 
И дойти может до того, что приложение просто перестанет отвечать на запросы, так как подключения к БД закончатся и новые запросы будут просто висеть в ожидании доступного подключения.

#### 5. Зависимость перебрасывания
У нас есть два репозитория с пакетами(разные библиотеки и прочее). Когда недоступен один, то мы обращаемся к другому.
По идее поломка первого репозитория не доставляет проблем проекту. И если считать что зависимость это ситуация когда поломка одного модуля портит работу другого,
то можно сказать, что проект не зависит от первого репозитория. Но если считать, что для зависимости достаточно чтобы один модуль вызывал/использовал другой, то проект зависит от репозитория. 
Хотя первый пункт вроде как опровергает это утверждение, поэтому я склоняюсь к тому, что тут нет зависимости между проектом и репозиторием. 
Хотя в таких случаях возникают вопросы, а что будет если перебрасывание не сработает?   

#### 6. Зависимость инверсии
С этой штукой я сталкиваюсь постоянно. Spring и его бины. Частенько разработчики вводят интерфейсы для каждого сервиса в проекте, независимо от количества реализаций.
Кажется, что у нас какое-то время тоже была такая практика. Код раздувался, а смысла в этом было не очень много. В итоге мы пришли к тому, что если у интерфейса не предвидится больше одной реализации,
то в классе пользователе можно сразу применять реализацию, а интерфейс вообще не создавать.

#### 7. Зависимость зацикливания
Столкнулся с этим в дипломном проекте. В рамках выполнения одного из заданий по созданию TG-бота у меня образовалась циклическая зависимость.
Класс бота знал о географическом сервисе, а географический сервис знал о боте. Дошёл до такой ситуации по мере развития бота,
когда понадобилось отправлять уведомления о создании поездки менеджерам предприятия. Spring выкидывал ошибки, что не может решить в каком порядке создавать бины, так как есть циклическая зависимость.
Для решения проблемы использовал аннотацию Lazy, чтобы один из бинов инициализировался не при старте приложения, а позднее. 
Но вообще держал в уме, что в будущем нужно переделать архитектуру и в планах переход на работу с сообщениями.  

#### 8. Зависимость высшего порядка
Когда я только начинал использовать инструменты Spring для работы с БД, то познакомился с одной его особенностью. Я использовал аннотацию Transactional, 
чтобы мой метод работал с БД в рамках одной транзакции. Но понял, что транзакция не будет работать, если вызвать метод, помеченный этой аннотацией, из того же класса, в котором он прописан.
Затем я выяснил как там всё работает под капотом, и что Spring создаёт прокси для метода вызываемого класса, в котором выполняется обёртка в транзакцию. Но если вызов 
аннотированного метода происходит в рамках того же класса, то прокси не будет создан и аннотация не отработает.
Для решения проблемы можно поменять структуру классов так, чтобы нужный метод всегда вызывался из другого класса и прокси работал. А можно использовать ряд других инструментов.
В том случае я использовал TransactionTemplate, чтобы можно было вызывать нужный мне метод из того же класса и всё работало в транзакции, также благодаря этому подходу я 
смог ограничить область транзакции и убрать из неё пару ненужных вызовов. 

#### 9. Зависимость большинства
Кажется, что в своей практике с подобным я не встречался. Сначала даже не совсем понял о чём пункт, но потом почитал про "N-version programming" и всё стало немного яснее.
Если отвечать на вопрос пункта: "Но разве можно сказать, что она не зависит ни от одной из пяти программ?". То тут опять всё зависит от того, что мы понимаем по словом "зависимость".
Наверное, до ознакомления с этим материалом, я бы ответил, что система зависит от каждой из программ, так как использует их. 
Но на текущий момент я определяю зависимость как способность одной части повлиять на другую(например поломать). И с этой позиции кажется, что система не зависит какой-то конкретной реализации,
но зависит от нескольких реализаций сразу(в примере из этого пункта она зависит как минимум от трёх любых реализаций, которые выдают одинаковый ответ).

#### Вывод
Материал показался сложным, он поднимает ряд вопросов, но ответов не даёт, а заставляет подумать. Тут один пункт как будто наводит тебя на какую-то мысль, а другой может задавать такой вопрос,
который эту мысль ставит под сомнение. Кажется, что часть ответов будет в следующих материалах.  
Иначе взглянул на понятие зависимости. Раньше я особо не задумывался об этом, в голове содержалось что-то примитивное: если A использует B, то A зависит от B. 
Но в ходе занятия понял, что далеко не всё так однозначно и тема зависимостей сложнее, чем может показаться на первый взгляд.
Тут есть много нюансов и хорошо бы чётко обозначить каждое понятие, а мы частенько в одно и то же слово вкладываем разные смыслы, иногда даже в рамках единого предложения.
В рамках занятия вывел для себя новое определение зависимости, которое упомянул в пункте 9. Но есть ощущение, что всё устроено сложнее и моё определение не отражает всей сути этого понятия.
Надеюсь в следующих занятиях лучше понять эту тему.