### Пример 1
<details>
<summary>До</summary>

```java
@RestController
public class EnterpriseRestController {
    ...
    
    @PostMapping
    public ResponseEntity<?> create(@RequestBody EnterpriseDto enterpriseDto) {
        Manager manager = securityUtils.getCurrentManager();
        Enterprise newEnterprise = toEnterpriseConverter.convert(enterpriseDto);

        enterpriseService.saveWithManager(newEnterprise, manager);

        URI location = ServletUriComponentsBuilder.fromCurrentRequest()
                .path("/{id}")
                .buildAndExpand(newEnterprise.getId())
                .toUri();
        return ResponseEntity.created(location).body(toEnterpriseDtoConverter.convert(newEnterprise));
    }
}

@Service
@RequiredArgsConstructor
public class EnterpriseService {
    private final EnterpriseRepository enterpriseRepository;
    private final ManagerService managerService;

    @Transactional
    public void saveWithManager(Enterprise enterprise, Manager manager) {
        //Повторно ищем менеджера, чтобы он был в attached-статусе.
        //todo Улучшить дизайн
        Manager curManager = managerService.getManagerByUsername(manager.getUsername());
        enterprise.setManagers(Set.of(curManager));
        //Менеджер является владельцем связи, поэтому hibernate отслеживает его изменения.
        // Без этой строки не добавится связь между менеджером и предприятием.
        curManager.getEnterprises().add(enterprise);

        enterpriseRepository.save(enterprise);
    }
    ...
}

```
</details>

<details>
<summary>После</summary>

```java
@RestController
public class EnterpriseRestController {
    ...
    
    @PostMapping
    public ResponseEntity<?> create(@RequestBody EnterpriseDto enterpriseDto) {
        Enterprise newEnterprise = toEnterpriseConverter.convert(enterpriseDto);

        enterpriseService.saveWithCurrentManager(newEnterprise);

        URI location = ServletUriComponentsBuilder.fromCurrentRequest()
                .path("/{id}")
                .buildAndExpand(newEnterprise.getId())
                .toUri();
        return ResponseEntity.created(location).body(toEnterpriseDtoConverter.convert(newEnterprise));
    }
}

@Service
@RequiredArgsConstructor
public class EnterpriseService {
    private final EnterpriseRepository enterpriseRepository;
    private final SecurityUtils securityUtils;

    public void saveWithCurrentManager(Enterprise enterprise) {
        enterprise.getManagers().add(securityUtils.getCurrentManager());

        enterpriseRepository.save(enterprise);
    }
    ...
}

```
</details>

Отрефакторил код создания предприятия. Кажется, что это можно назвать нормальным рефакторингом (однако есть небольшие сомнения :), а не местным улучшением кода.
Изменил сигнатуру сервисного метода, который отвечает за сохранение предприятия. Также поменялись зависимости сервиса. Избавился от избыточных походов в БД.
Менеджер и предприятие связаны как m2m. В модели изменил владельца связи с менеджера на предприятие (код не стал приводить в примерах), чтобы связь между менеджером и предприятием корректно обновлялась, так как hibernate следит именно за владельцем связи и раньше приходилось выполнять дополнительные действия, чтобы всё сохранялось ожидаемым образом.
Кажется, что получившийся код стал проще для восприятия, так как я отсёк лишнее. А получившийся метод больше соответствует текущим процессам. Нам пока не нужно сохранять предприятие с произвольным менеджером. Изначальная задача метода -- сохранить предприятие, связав его с залогиненным менеджером. 
Границы тут задаются скорее явно, через интерфейс(название метода и параметры).

### Пример 2
<details>
<summary>До</summary>

```java
public class MessageServiceProdImpl implements MessageService {
    @Override
    public SendMessageResult sendToAccounts(long messageId, Collection<String> serviceAccountNumbers,
                                            boolean isPopup) {
        return ctx.getSession().doInTransaction(() -> {
            MessageDto message = messageDao.findById(ctx.getSession(), messageId)
                    .orElseThrow(MessageNotFoundException::new);

            return internalSendToAccounts(message, serviceAccountNumbers,
                    isPopup, nsqServiceFactory.apply(ctx, true)::sendToPersonalMessagesTopic);
        });
    }
}

public class MessageAddAndSendToAcc extends MessageAdd {

    private final Function<ExecutionContext, MessageService> messageServiceFactory;
    private final Converter<SendMessageResult, CommandResult> converter;

    public MessageAddAndSendToAcc(Entity entity) {
        super(entity);
        messageServiceFactory = MessageServiceProdImpl::new;
        converter = new SendMessageResultToCommandResultConverter();
    }

    public MessageAddAndSendToAcc(Entity entity, Map<String, String> params) {
        super(entity, params);
        messageServiceFactory = MessageServiceProdImpl::new;
        converter = new SendMessageResultToCommandResultConverter();
    }

    public MessageAddAndSendToAcc(Entity entity, MessageService messageService) {
        super(entity);
        messageServiceFactory = ctx -> messageService;
        converter = new SendMessageResultToCommandResultConverter();
    }

    @Override
    public CommandResult invoke(ExecutionContext ctx, Map<String, String> params) {
        CommandResult result;

        String transactionId = ParamHelper.getStringParam(params, "transactionId", null);
        TransactionHelper.startTransaction(ctx, transactionId, "MessageAddAndSend");

        Session session = ctx.getSession();
        try {
            session.startTransaction();

            long messageId = Long.parseLong(saveMessage(ctx, params));

            Set<String> serviceAccountNumbers = ParamHelper.getStringParamAsNotEmptySet(params,
                    "service.account.numbers");
            boolean isPopup = ParamHelper.getBooleanIntParam(params, "isPopup", false);

            SendMessageResult sendMessageResult = messageServiceFactory.apply(ctx)
                    .sendToAccounts(messageId, serviceAccountNumbers, isPopup);
            result = converter.convert(sendMessageResult);

            TransactionHelper.endTransaction(ctx, transactionId, 1, "");

            session.commit();
        } catch (Exception e) {
            TransactionHelper.endTransaction(ctx, transactionId, -2, e.getMessage());
            result = makeResultFromException(e);
            logger.error(e.getMessage(), e);
            session.rollback();
        } finally {
            session.close();
        }

        return result;
    }

}
```
</details>

<details>
<summary>После</summary>

```java
@Component
public class MessageDtoConverter implements Converter<Map<String, String>, MessageDto> {

    public static final String DATE_TIME_FORMAT = "MM/dd/yyyy HH:mm:ss";

    @SneakyThrows
    @Override
    public MessageDto convert(Map<String, String> params) {
        String startDateString = ParamHelper.getStringParam(params, "message.start.date", null);
        Date startDate = startDateString != null ? DateUtils.parse(startDateString, DATE_TIME_FORMAT) : new Date();

        String stopDateString = ParamHelper.getStringParam(params, "message.stop.date", null);
        Date stopDate = stopDateString != null ? DateUtils.parse(stopDateString, DATE_TIME_FORMAT) : null;

        String validToDateString = ParamHelper.getStringParam(params, "message.valid.date", null);
        Date validToDate;
        if (validToDateString != null) {
            validToDate = DateUtils.parse(validToDateString, DATE_TIME_FORMAT);
        } else if (stopDate != null) {
            validToDate = stopDate;
        } else {
            validToDate = DateTimeHelper.getInstance().addDays(new Date(), 1);
        }

        MessageDto message = new MessageDto();
        message.setName(ParamHelper.getStringParamNotEmpty(params, "message.name"));
        message.setDescriptionLong(ParamHelper.getStringParamNotEmpty(params, "message.text"));
        message.setExternalId(ParamHelper.getStringParam(params, "message.external.id",null));
        message.setStartDate(startDate);
        message.setEndDate(stopDate);
        message.setValidToDate(validToDate);
        message.setServiceSpecExternalId(ParamHelper.getStringParam(params, "service.spec.external.id", null));
        message.setLinkedId(ParamHelper.getLongParam(params, "message.object.id", null));
        message.setLinkedDiscriminator(ParamHelper.getStringParam(params, "message.object.type", null));
        message.setIgnoreMessageBan(ParamHelper.getBooleanParam(params, "message.ignore.ban", null));
        message.setDuration(ParamHelper.getIntegerParam(params, "message.popup.timeout", null));

        return message;
    }
}

public class MessageServiceProdImpl implements MessageService {
    ...
    @Override
    public SendMessageResult sendToAccounts(MessageDto message, Collection<String> serviceAccountNumbers,
                                            boolean isPopup) {
        return internalSendToAccounts(message, serviceAccountNumbers,
                isPopup, nsqServiceFactory.apply(ctx, true)::sendToPersonalMessagesTopic);
    }
    ...
}

@Component
@RequiredArgsConstructor
public class MessageAddAndSendToAcc extends Command {

    private final MessageService messageService;
    private final SendMessageResultToCommandResultConverter commandResultConverter;
    private final MessageDtoConverter paramsConverter;

    @Override
    public CommandResult invoke(ExecutionContext ctx, Map<String, String> params) {
        CommandResult result;
        try {
            Set<String> serviceAccountNumbers = ParamHelper.getStringParamAsNotEmptySet(params,
                    "service.account.numbers");
            boolean isPopup = ParamHelper.getBooleanIntParam(params, "isPopup", false);
            MessageDto message = paramsConverter.convert(params);

            SendMessageResult sendMessageResult = messageService.sendToAccounts(message,
                    serviceAccountNumbers, isPopup);
            result = commandResultConverter.convert(sendMessageResult);

        } catch (Exception e) {
            result = makeResultFromException(e);
            log.error(e.getMessage(), e);
        }

        return result;
    }
}
   
```
</details>

В ходе жизни проекта часть функционала потеряла свою актуальность и мы проводили рефакторинг, удаляя лишнее и перестраивая то что у нас было.
И в рамках таких работ я выполнял рефакторинг части проекта отвечающей за отправку сообщений. Показалось, что он неплохо соотносится с текущим занятием.
Задача кода: Отправить переданное сообщение клиентам из переданного списка учётных записей. 
Как было раньше: получали сообщение, парсили в мапу, вызывали метод сохранения сообщения в БД, доставали его из БД и отправляли на учётки.
Как стало: получили сообщение, конвертировали в нужный формат, отправили на учётки.
Из цикла убрана БД, при этом для клиентов и пользователей интерфейса ничего не поменялось.
Код стал проще, быстрее и надёжнее. Думаю будет верно сказать, что он стал более самостоятельным(или вернее снизилась связность/сцеплённость?), потому что теперь мы вообще не зависим от команды сохранения сообщений в БД и сервиса по их извлечению.
Тут границы скорее заданы через документацию, так как входные параметры метода передаются в мапе, а информация о них находится в документации. Результат выполнения метода также передаётся в универсальной структуре и формат ответа описан в документации.

#### Тесты для примера
В рамках этого же рефакторинга были сделаны тесты. Кажется, что эти тесты не просто юниты. Так как в них вызывается команда и проверяется её ответ. 
Мы не сосредотачиваемся на том, что происходит внутри этой команды, тут нам интересен результат. Мы смотрим, что при вызове метода отправки сообщения, оно действительно отправляется куда нужно.

<details>
<summary>Код</summary>

```java
public class MessageAddAndSendToAccTest extends AssertH2Connection {

    private MessageAddAndSendToAcc command;
    private Publisher mockPublisher;

    @Override
    protected String getScriptFromClasspath() {
        return "db/custom_dml/MessageAddAndSendTest.sql";
    }

    @Before
    public void beforeEach() {
        mockPublisher = mock(Publisher.class);
        command = new MessageAddAndSendToAcc(entity,
                new MessageServiceProdImpl(ctx).toBuilder()
                        .nsqServiceFactory((ctx, onCommit) -> (new NsqServiceImpl(() -> mockPublisher)))
                        .internalIdService(mock(InternalIdService.class)).build());
        ConfigurationHelper.setProperty("nsq.topic.personal.messages", "personal_messages");
        ConfigurationHelper.setProperty("nsq.enabled", "true");
    }

    @Test
    public void testSendToOneAccount() throws IOException {
        String accountNumber = "100500";
        String messageName = "testName";
        String messageText = "testText";
        String messageExternalId = "testExt";
        String messagePopupTimeout = "10";
        String messageObjectType = "CHANNELPACKAGE";
        Long messageObjectId = 223L;
        String messageStartDate = "12/22/2023 12:04:00";
        Long messageStartDateLong = 1703246640L;
        String messageStopDate = "12/24/2023 12:04:00";
        Long messageStopDateLong = 1703419440L;
        String messageValidDate = "12/25/2023 12:22:00";
        Long messageValidDateLong = 1703506920L;

        ArgumentCaptor<byte[]> messageCaptor = ArgumentCaptor.forClass(byte[].class);

        Map<String, String> params = new HashMap<>();
        params.put("message.name", messageName);
        params.put("message.text", messageText);
        params.put("service.account.numbers", accountNumber);
        params.put("message.external.id", messageExternalId);
        params.put("message.start.date", messageStartDate);
        params.put("message.stop.date", messageStopDate);
        params.put("message.valid.date", messageValidDate);
        params.put("isPopup", "0");
        params.put("message.popup.timeout", messagePopupTimeout);
        params.put("service.spec.external.id", "SS_EXT_ID");
        CommandResult result = command.invoke(ctx, params);

        assertEquals(result.getResult(), Integer.valueOf(0));
        assertNull(result.getData().getChild("warnings"));

        verify(mockPublisher, times(1)).publishBuffered(eq("personal_messages"), messageCaptor.capture());
        byte[] data = messageCaptor.getValue();
        ObjectMapper objectMapper = new ObjectMapper();
        objectMapper.setPropertyNamingStrategy(PropertyNamingStrategy.SNAKE_CASE);
        objectMapper.setSerializationInclusion(JsonInclude.Include.NON_NULL);
        MessageContainer messageContainer = objectMapper.readValue(data, MessageContainer.class);

        assertEquals(messageContainer.message.duration, Integer.valueOf(messagePopupTimeout));
        assertFalse(messageContainer.isPopup);
        assertEquals(messageContainer.message.name, messageName);
        assertEquals(messageContainer.message.text, messageText);
        assertEquals(messageContainer.message.externalId, messageExternalId);
        assertEquals(messageContainer.message.startDate, messageStartDateLong);
        assertEquals(messageContainer.message.stopDate, messageStopDateLong);
        assertEquals(messageContainer.message.validDate, messageValidDateLong);
        assertEquals(messageContainer.message.objectId, messageObjectId);
        assertEquals(messageContainer.message.objectType, messageObjectType);
        assertEquals(messageContainer.serviceAccountNumbers, Arrays.asList(accountNumber.split(",")));
    }

    @Test
    public void testSendToTwoAccounts() throws IOException {
        String accountNumber = "100500,200600";
        String messageName = "testName";
        String messageText = "testText";
        String messageExternalId = "testExt";
        String messagePopupTimeout = "0";
        String messageObjectId = "324";
        String messageObjectType = "TYPE";

        ArgumentCaptor<byte[]> messageCaptor = ArgumentCaptor.forClass(byte[].class);

        Map<String, String> params = new HashMap<>();
        params.put("message.name", messageName);
        params.put("message.text", messageText);
        params.put("service.account.numbers", accountNumber);
        params.put("message.external.id", messageExternalId);
        params.put("isPopup", "0");
        params.put("message.popup.timeout", messagePopupTimeout);
        params.put("message.object.id", messageObjectId);
        params.put("message.object.type", messageObjectType);
        CommandResult result = command.invoke(ctx, params);

        assertEquals(result.getResult(), Integer.valueOf(0));
        assertNull(result.getData().getChild("warnings"));

        verify(mockPublisher, times(1)).publishBuffered(eq("personal_messages"), messageCaptor.capture());
        byte[] data = messageCaptor.getValue();
        ObjectMapper objectMapper = new ObjectMapper();
        objectMapper.setPropertyNamingStrategy(PropertyNamingStrategy.SNAKE_CASE);
        objectMapper.setSerializationInclusion(JsonInclude.Include.NON_NULL);
        MessageContainer messageContainer = objectMapper.readValue(data, MessageContainer.class);

        assertEquals(messageContainer.message.duration, Integer.valueOf(messagePopupTimeout));
        assertFalse(messageContainer.isPopup);
        assertNull(messageContainer.message.stopDate);
        assertTrue(messageContainer.message.startDate - DateUtils.getUtc(new Date()) < 30);
        Date tomorrow = DateTimeHelper.getInstance().addDays(new Date(), 1);
        assertTrue(messageContainer.message.validDate - DateUtils.getUtc(tomorrow) < 30);
        assertEquals(messageContainer.message.name, messageName);
        assertEquals(messageContainer.message.text, messageText);
        assertEquals(messageContainer.message.externalId, messageExternalId);
        assertEquals(messageContainer.message.objectId, Long.valueOf(messageObjectId));
        assertEquals(messageContainer.message.objectType, messageObjectType);
        assertEquals(messageContainer.serviceAccountNumbers, Arrays.asList(accountNumber.split(",")));
    }

    @Test
    public void testSendToOneValidAndOneMissingAccount() throws IOException {
        String existingAccount = "100500";
        String notExistingAccount = "300600";
        String messageName = "testName";
        String messageText = "testText";
        String messageExternalId = "testExt";
        String messageStopDate = "12/24/2023 12:04:00";
        Long messageStopDateLong = 1703419440L;

        ArgumentCaptor<byte[]> messageCaptor = ArgumentCaptor.forClass(byte[].class);

        Map<String, String> params = new HashMap<>();
        params.put("message.name", messageName);
        params.put("message.text", messageText);
        params.put("service.account.numbers", String.join(",", existingAccount, notExistingAccount));
        params.put("message.external.id", messageExternalId);
        params.put("message.stop.date", messageStopDate);
        params.put("isPopup", "0");
        params.put("message.popup.timeout", null);
        CommandResult result = command.invoke(ctx, params);

        assertEquals(result.getResult(), Integer.valueOf(0));
        assertNotNull(result.getData().getChild("warnings").getChild("warning").getChild("300600 not found"));

        verify(mockPublisher, times(1)).publishBuffered(eq("personal_messages"), messageCaptor.capture());
        byte[] data = messageCaptor.getValue();
        ObjectMapper objectMapper = new ObjectMapper();
        objectMapper.setPropertyNamingStrategy(PropertyNamingStrategy.SNAKE_CASE);
        objectMapper.setSerializationInclusion(JsonInclude.Include.NON_NULL);
        MessageContainer messageContainer = objectMapper.readValue(data, MessageContainer.class);

        assertNull(messageContainer.message.duration);
        assertFalse(messageContainer.isPopup);
        assertEquals(messageContainer.message.name, messageName);
        assertEquals(messageContainer.message.text, messageText);
        assertEquals(messageContainer.message.externalId, messageExternalId);
        assertEquals(messageContainer.message.stopDate, messageStopDateLong);
        assertEquals(messageContainer.message.validDate, messageStopDateLong);
        assertEquals(messageContainer.serviceAccountNumbers, Arrays.asList(existingAccount.split(",")));
    }

}
```
</details>

### Пример 3
<details>
<summary>До</summary>

```java
public class DaDataClientDefault implements DaDataClient {
    public static final String DADATA_SERVICE_URL_PROP = "dadata.url";
    public static final String DADATA_TIMEOUT_PROP = "dadata.timeout.sec";
    private final Supplier<CloseableHttpClient> httpClientFactory;

    public DaDataClientDefault() {
        this.httpClientFactory = DaDataClientDefault::createDaDataHttpClient;
    }

    public DaDataClientDefault(Supplier<CloseableHttpClient> httpClientFactory) {
        this.httpClientFactory = httpClientFactory;
    }

    private static CloseableHttpClient createDaDataHttpClient() {
        return HttpClients.createDefault();
    }

    private static int getTimeoutMilliSec() {
        return 1000 * Integer.parseInt(ConfigurationHelper.getProperty(DADATA_TIMEOUT_PROP, "3"));
    }

    private String getBaseServiceUrl() {
        return ConfigurationHelper.getProperty(DADATA_SERVICE_URL_PROP);
    }

    @Override
    public CleanPhoneResponseDto requestCleanPhone(String phone) {
        CleanPhoneRequestDto requestEntity = new CleanPhoneRequestDto();
        requestEntity.setPhone(phone);

        String uri = getBaseServiceUrl() + "CleanService/doClean";
        HttpPost request = new HttpPost(uri);

        return exchangeEntity(request, requestEntity, CleanPhoneResponseDto.class);
    }

    /**
     * Сделать запрос по http, формат тела запроса и ответа - json.
     *
     * @param request
     * @param requestEntity
     * @param responseEntityClass
     * @param <T>
     * @param <R>
     * @return
     */
    private <T, R> T exchangeEntity(HttpEntityEnclosingRequestBase request,
                                    R requestEntity,
                                    Class<T> responseEntityClass) {

        final long startTime = System.currentTimeMillis();
        request.setHeader(HttpHeaders.CONTENT_TYPE, "application/json");
        request.setHeader(HttpHeaders.ACCEPT, "application/json");

        ObjectMapper mapper = new ObjectMapper();
        try {
            request.setEntity(new StringEntity(mapper.writeValueAsString(requestEntity), StandardCharsets.UTF_8));
        } catch (JsonProcessingException e) {
            log.error(e.getLocalizedMessage(), e);
            throw new DaDataCommunicationException("Can not convert object '" + requestEntity + "' to JSON");
        }

        int timeoutMillis = getTimeoutMilliSec();

        HttpTimer httpTimer = new HttpTimer();
        httpTimer.start(() -> {
            request.abort();
            log.warn("DaData request aborted by general timeout " + timeoutMillis + " ms");
        }, timeoutMillis);

        try (CloseableHttpClient httpClient = httpClientFactory.get();
             CloseableHttpResponse response = httpClient.execute(request)) {

            int statusCode = response.getStatusLine().getStatusCode();
            if (statusCode != HttpStatus.SC_OK) {
                throw new DaDataCommunicationException("got non 200 status code from DaData: " + statusCode);
            }
            String responseString = EntityUtils.toString(response.getEntity(), StandardCharsets.UTF_8);
            EntityUtils.consume(request.getEntity());
            EntityUtils.consume(response.getEntity());

            httpTimer.cancel();

            log.debug(responseString + "\n" + "query time: " + (System.currentTimeMillis() - startTime) + " ms");

            return mapper.readValue(responseString, mapper.getTypeFactory().constructType(responseEntityClass));
        } catch (SocketException | SocketTimeoutException e) {
            log.error(e.getLocalizedMessage(), e);
            throw new DaDataTimeoutException(e);
        } catch (IOException e) {
            log.error(e.getLocalizedMessage(), e);
            throw new DaDataCommunicationException(e);
        } finally {
            request.reset();
        }
    }
}
```
</details>

<details>
<summary>После</summary>

```java
public class DaDataClientDefault implements DaDataClient {
    public static final String DADATA_SERVICE_URL_PROP = "dadata.url";
    public static final String DADATA_TIMEOUT_PROP = "dadata.timeout.sec";
    private static final ObjectMapper JSON_CAMEL_CASE_MAPPER = getCamelCaseJsonMapper();
    private final WsHttpClient httpClient;

    public DaDataClientDefault() {
        this.httpClient = ClientPerRequestWsHttpClientWrapper.Builder
                .from(DaDataClientDefault::getConnectionParams)
                .setMapper(JSON_CAMEL_CASE_MAPPER)
                .build();
    }

    private static ConnectionParams getConnectionParams() {
        return ConnectionParams.builder()
                .requestTimeout(1000 * ConfigurationHelper.getIntProperty(DADATA_TIMEOUT_PROP, 3))
                .addHeader(HttpHeaders.CONTENT_TYPE, "application/json")
                .addHeader(HttpHeaders.ACCEPT, "application/json")
                .build();
    }

    private static ObjectMapper getCamelCaseJsonMapper() {
        ObjectMapper objectMapper = new ObjectMapper();
        objectMapper.setPropertyNamingStrategy(PropertyNamingStrategy.LOWER_CAMEL_CASE);
        objectMapper.setSerializationInclusion(JsonInclude.Include.NON_NULL);
        objectMapper.registerModule(new Jdk8Module());
        return objectMapper;
    }

    private String getBaseServiceUrl() {
        return ConfigurationHelper.getProperty(DADATA_SERVICE_URL_PROP);
    }

    @Override
    public CleanPhoneResponseDto requestCleanPhone(String phone) {
        CleanPhoneRequestDto requestEntity = new CleanPhoneRequestDto();
        requestEntity.setPhone(phone);

        String uri = getBaseServiceUrl() + "CleanService/doClean";

        try {
            return httpClient.postJson(uri, requestEntity, CleanPhoneResponseDto.class);
        } catch (Exception e) {
            throw new DaDataException(e);
        }
    }
}
```
</details>

Нашему сервису нужно общаться с разными внешними системами. Для общения используются http-клиенты. В итоге сложилась такая ситуация, что один и тот же код http-клиента копировался по проекту с незначительными изменениями, так как многие классы сами определяли логику взаимодействия с внешней системой.
Для решения проблемы решили выделить интерфейс клиента и сделать его базовую реализацию, через которые будет проходить взаимодействие со всеми внешними сервисами. В рамках одной из задач я переводил один из классов для взаимодействия с внешней системой на работу с этим универсальным клиентом.
Каков результат всего этого рефакторинга: выделена общая сущность http-клиент для взаимодействия с внешними системами. Теперь все кому нужно общаться с внешней системой используют единый интерфейс. Это снизило количество дублированного кода. У нас появилась одна точка с единой логикой взаимодействия с внешними системами.
Задача нового интерфейса пойти передать запрос во внешнюю систему и вернуть её ответ. Параметры, форматы ответов могут быть различными, но логика взаимодействия теперь общая. Границы задаются явно через интерфейсы. 

### Выводы 
Задание было довольно интересным, хотя и не простым. Благодаря материалу из этого задания я смог увидеть ряд своих слабостей, которым планирую уделить внимание. 
Осознал, что хороший рефакторинг мне как будто бы не очень даётся. Вроде всё сделал, но как будто можно было лучше, надеюсь с опытом всё придёт. 
Есть такое ощущение, что мне пока тяжело обозначать чёткие связи между частями системы, выделять их границы, выражать ключевые концепты. Как будто не хватает уверенности или какого-то понимания, что именно делать или как должен выглядеть ключевой концепт. Хотя может я просто зря сомневаюсь в себе.  
В некоторых пунктах материала увидел себя (страх делать нелокальные изменения проекта). 
Были полезны замечания по ревью, тоже увидел в них себя. Иногда я слишком сильно закапываюсь в мелкие детали при ревью кода, хотя первым делом следовало бы сосредоточиться на более глобальных вещах "что код делает?", а не "как код делает?".
В будущих ревью буду пытаться в первую очередь изучать код на более высоком уровне, да и в целом стараться думать на уровне концепций. Вижу, что эта идея продвигается уже далеко не первое занятие, но с каждым разом ты видишь, всё больше и больше доказательств того, что это действительно важно. 
Из этого материала я почерпнул ряд полезных вещей, но чувствую, что тут ещё можно извлечь много ценного. Вообще возникло такое ощущение, будто я оказался на пороге осознания и принятия чего-то важного, что выведет мой подход к разработке на новый уровень.
Хоть я и читал материал уже несколько раз, но пока не произошло того щелчка, после которого написанное там стало бы частью моих взглядов и целиком вписалось бы в мою картину мира.
Так что точно нужно будет возвращаться к этому материалу и может не один раз. Нужно докрутить его и сделать так, чтобы всё встроилось в мою текущую картину. 
Однако даже сейчас я увидел ряд своих проблем и на собственном опыте прочувствовал правильность части вещей, о которых говорится в учебном материале. 