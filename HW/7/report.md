Нашёл в коде рабочего проекта только один случай с неистинным наследованием.  
[Изначальный код](before) классов JoinPart и его наследников LocaleJoin, JoinPartExtended и ObjectLinkJoinPart.

Тут видно, что у каждого класса есть метод getSql, при чём в наследниках он переопределяется и ни в одном из них не вызывается родительский метод.

[Обновлённый код](after) содержит вызов посетителя, которой заменил собой метод getSql. 

Пример кажется не совсем удачным, так как в методе visit слишком много параметров, кажется, что там должен быть лишь класс, который мы посещаем. 
Это позволит делать разнообразные реализации интерфейса Visitor и применять их без изменения основных классов. 
В моём же случае все новые реализации Посетителя должны принимать ряд параметров, помимо самого объекта. А ведь эти параметры где-то для какой-нибудь логики могут быть совсем не нужны.
Однако без их использования не получилось бы перевести код на работу с шаблоном Посетитель. 

### Выводы
Я познакомился с паттерном Visitor. Он используется в некоторых местах нашего проекта, но мне так и не довелось взаимодействовать с ними. 
Я однажды пытался разобраться с этим паттерном в нашем коде, но его реализация показалась мне сложной и я отложил разбор до тех пор,
пока не придётся столкнуться с соответствующими частями кода в рамках рабочих задач (не столкнулся до сих пор).
В рамках же текущего занятия мне пришлось изучить этот паттерн. Пока впечатления смешанные. Я как будто бы понял где его можно применить, но пока не смог прочувствовать его мощи.
Помню на одном из дейликов коллега восторгался этим паттерном, когда смог его применить в своей задаче, при этом он тоже видел части кода с реализацией этого паттерна в основном проекте.
Но сказал, что тогда особо не вникал в его детали и не чувствовал его мощи, а теперь, когда с помощью него решилась рабочая задача он прочувствовал силу Посетителя. 
Надеюсь, что у меня скоро будет также и прочувствую силу этого паттерна.
Сейчас же есть ощущение, что он нужен далеко не везде и далеко не всегда (хотя это наверное норма, так как цели тех или иных шаблонов -- решать свой класс задач).
Понял, что паттерн полезен, когда нужно добавить какую-то логику в класс, который лучше не менять, либо эта логика не очень хорошо вяжется с классом и её лучше поместить отдельно.
Понравилось то, что при реализации этого паттерна можно совершать различные действия с объектами. Добавили метод accept в класс и можем передавать ему Посетителей с разнообразной логикой,
а исходный класс при этом менять не нужно.

Некоторые трудности возникли с пониманием смысла истинного наследования. Но, кажется, что несколько прочтений учебного материала помогли найти ответ.
Если я всё верно понял, то истинное наследование позволяет соблюсти LSP. А полное переопределение родительского класса, от которого мы избавлялись в рамках этого занятия, его нарушает.   