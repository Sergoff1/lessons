#### 1. Зависимость фреймворка
Возьмём для примера Spring. Кажется, что корректность работы Спринга, в целом, не зависит от его бинов. Спринг их создаёт, управляет ими и т.д. Он выше своих бинов. 
Но мы можем сделать такие бины, которые будут портить работу Спринга и приведут к ошибкам. Например, если в бинах будет циклическая зависимость, то по умолчанию 
Спринг будет выдавать ошибку и говорить, что он не знает как её разрешить. Думаю, что одним из вариантов решения такой проблемы будет запрет на создание циклических зависимостей.
Можно договориться в команде/зафиксировать в спеке запрет на это и всегда выстраивать архитектуру так, чтобы такие зависимости не возникали. Благодаря этому мы не будем получать ошибки такого класса.    

#### 2. Зависимость расшаренного формата
На работе был случай, когда после рефакторинга наш сервис стал отправлять другому новый параметр в одном из запросов(вроде даже пустой).
В результате сторонний сервис не мог обработать запрос и возвращал ошибку. Для исправления ситуации мы просто убрали ненужный параметр.
Думаю, что одним из вариантов решения этой зависимости будет создание спецификации, в которой будет прописан общий формат данных.  

#### 3. Зависимость зависимости
У нас есть два вроде независимых проекта, для них настроены пайплайны, одним из шагов которых является сборка rpm-пакета с приложением и сохранение этого пакета в специальном репозитории.
Оба проекта сохраняют свои пакеты в один репозиторий. Долгое время все работало хорошо. Но однажды мы столкнулись с тем, что пайплайн отработал(отмечен зелёными галочками),
но пакета в репозитории не было. Начали разбираться в чём дело и оказалось, что если в двух разных проектах будет запущен этап загрузки пакета в репозиторий примерно в одно время,
то пайплайн, который начал задачу чуть позже не отработает как ожидается(пакет не окажется в репозитории), при чём ошибок он тоже не выдаст.
Для решения проблемы стали просто учитывать эту особенность и не запускать пайплайны по этим двум проектам в одно время. 
Это решение мы зафиксировали в вики, прописав запрет на одновременный запуск сборочных пайплайнов в этих двух проектах.

#### 4. Зависимость краша
В качестве примера тут можно привести репозитории, через которые мы обращаемся к БД из кода. На первый взгляд два репозитория не зависят друг от друга.
Например, один может давать информацию о менеджерах предприятия, а второй о моделях автомобилей предприятия. Они обращаются к разным таблицам, используются в разных сервисах и т.д.
Но по умолчанию Spring Boot используется пул из 10 подключений к БД, и репозитории, чтобы обработать запрос, берут подключения из этого пула.
Получается, если в одном репозитории будут использоваться проблемные запросы(долго выполняются, не отдают подключения), то может пострадать работоспособность другого репозитория,
так как они используют общий пул подключений. Получается, что один репозиторий может повлиять на работу других.
И дойти может до того, что приложение просто перестанет отвечать на запросы, так как подключения к БД закончатся и новые запросы будут просто висеть в ожидании доступного подключения.
Если я всё верно понимаю, то эту проблему можно решить с помощью суперспецификации. Нужно обозначить в ней запрет на создание запросов, которые способны приводить к замедлению работы системы.

#### 5. Зависимость перебрасывания
У нас есть два репозитория с пакетами(разные библиотеки и прочее). Когда недоступен один, то мы обращаемся к другому.
Недоступность первого репозитория не доставляет проблем проекту. Один репозиторий тут является лишь частью зависимости, а целиком она будет выглядеть как-то так: {repo1, repo2}. 
Значительные проблемы мы ощутим лишь тогда, когда откажут оба репозитория.

#### 6. Зависимость инверсии
Кажется, что в моей практике не было проблем с инверсией. Но насколько я понял: не нужно слишком увлекаться инверсией зависимостей, 
всё равно модуль 'A' откажет, если модуль 'B' окажется проблемным. А ещё, с инверсией мы лишим себя преимуществ статического тайп-чекинга.

#### 7. Зависимость зацикливания
Столкнулся с этим в дипломном проекте. В рамках выполнения одного из заданий по созданию TG-бота у меня образовалась циклическая зависимость.
Класс бота знал о географическом сервисе, а географический сервис знал о боте. Дошёл до такой ситуации по мере развития бота,
когда понадобилось отправлять уведомления о создании поездки менеджерам предприятия. Spring выкидывал ошибки, что не может решить в каком порядке создавать бины, так как есть циклическая зависимость.
Для решения проблемы использовал аннотацию Lazy, чтобы один из бинов инициализировался не при старте приложения, а позднее. 
Это самый быстрый способ устранения проблемы, но вообще лучше переработать архитектуру проекта.

#### 8. Зависимость высшего порядка
Когда я только начинал использовать инструменты Spring для работы с БД, то познакомился с одной его особенностью. Я использовал аннотацию Transactional,
чтобы мой метод работал с БД в рамках одной транзакции. Но понял, что транзакция не будет работать, если вызвать метод, помеченный этой аннотацией, из того же класса, в котором он прописан.
Затем я выяснил как там всё работает под капотом, и что Spring создаёт прокси для метода вызываемого класса, в котором выполняется обёртка в транзакцию. Но если вызов
аннотированного метода происходит в рамках того же класса, то прокси не будет создан и аннотация не отработает.
Кажется, что такую проблему(да и вообще проблемы такого класса) можно решить с помощью задания правильной спецификации, которая будет накладывать ограничения на те или иные моменты в поведении модуля.
Например, мы можем внедрить какие-нибудь предусловия, которые запретят состояния, способные привести к проблемам.

#### 9. Зависимость большинства
Опять эта сложная зависимость, с которой я не встречался на практике. Меня порадовало то, что в первом занятии я смог определить эту зависимость так, как это описано в текущем занятии.
Теперь я точно знаю, что в этом случае нет зависимости от какого-то конкретного элемента.
Мы зависим сразу от множества элементов и, наверное, на эту зависимость можно влиять изменяя число элементов в множестве. Обычно точность/надёжность будет тем выше, чем больше элементов задействовано.   

#### Вывод
Кажется это заключительное занятие по зависимостям. В ходе этих занятий я стал иначе смотреть на зависимости. 
Кажется, что главная вещь здесь заключается в том, что зависимость не так проста и однозначна, и будет неверно говорить, будто одна вещь целиком зависит от другой.
Правильнее сказать, что определённое свойство какой-либо вещи зависит от другой вещи. При этом нужно учитывать вычислительную модель и пространство допустимых изменений. 
Иногда какой-либо модуль может быть лишь частью зависимости и рассматриваемое свойство объекта будет зависеть сразу от нескольких модулей.
Был интересен момент с нетранзитивностью зависимости в примере с зацикливанием. Раньше думал, что тут всё однозначно, но это оказалось не так.
В рамках же этого занятия увидел несколько новых способов избавления от зависимостей, которые мы изучили раньше. Хотя я и не уверен, что понял всё. 
Но, как минимум, есть неплохая пища для дальнейших размышлений и мой взгляд на зависимости уже не будет прежним.