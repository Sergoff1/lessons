#### 1. Методы, которые используются лишь в тестах
<details>
<summary>До</summary>

```java
public class TerminalGetInfoCommand extends DbCommand {
    private Function<ExecutionContext, TerminalService> terminalServiceFactory = DefaultTerminalService::new;
    private Validator<Map<String, String>> commandValidator = new TerminalGetInfoValidator();
    private Converter<TerminalInfo, CommandResult> terminalInfoToCommandResultConverter
            = new TerminalInfoToCommandResultConverter();

    /**
     * Конструктор для прода.
     */
    @SuppressWarnings({"UnusedDeclaration"})
    public TerminalGetInfoCommand(Entity entity) {
        super(entity);
    }

    /**
     * Конструктор для прода.
     */
    @SuppressWarnings({"UnusedDeclaration"})
    public TerminalGetInfoCommand(Entity entity, Map<String, String> params) {
        super(entity, params);
    }

    /**
     * Конструктор для тестов.
     */
    @SuppressWarnings({"UnusedDeclaration"})
    public TerminalGetInfoCommand(Entity entity, Function<ExecutionContext, TerminalService> terminalServiceFactory,
                                  Validator<Map<String, String>> paramValidator,
                                  Converter<TerminalInfo, CommandResult> terminalInfoToCommandResultConverter) {
        super(entity);
        this.terminalServiceFactory = terminalServiceFactory;
        this.commandValidator = paramValidator;
        this.terminalInfoToCommandResultConverter = terminalInfoToCommandResultConverter;
    }

    /**
     * Конструктор для тестов.
     */
    @SuppressWarnings({"UnusedDeclaration"})
    public TerminalGetInfoCommand(Entity entity, Map<String, String> params,
                                  Function<ExecutionContext, TerminalService> terminalServiceFactory,
                                  Validator<Map<String, String>> commandParamaterValidator,
                                  Converter<TerminalInfo, CommandResult> terminalInfoToCommandResultConverter) {
        super(entity, params);
        this.terminalServiceFactory = terminalServiceFactory;
        this.commandValidator = commandParamaterValidator;
        this.terminalInfoToCommandResultConverter = terminalInfoToCommandResultConverter;
    }
...
}
```
</details>

<details>
<summary>После</summary>

```java
@Component
@RequiredArgsConstructor
public class TerminalGetInfoCommand extends Command {
    private final TerminalService terminalService;
    private final Validator<Map<String, String>> terminalGetInfoValidator;
    private final Converter<TerminalInfo, CommandResult> terminalInfoToCommandResultConverter;
...
}
```
</details>

В классе было 2 конструктора, которые использовались только в тестах(через них внедрялись моки). 
Перевёл класс на Спринговую инициализацию, избавился от лишних конструкторов (было 4 конструктора, остался 1). 
Теперь для внедрения моков не нужен отдельный конструктор. Да и вообще появилось больше гибкости.

#### 2. Цепочки методов
<details>
<summary>До</summary>

```java

public class RequestSubscribeFacade {
    ...

    public RequestSubscribeResult subscribeOn(SubscribeOnRequest request) {
        final Session session = ctx.getSession();

        return session.doInTransaction(() -> {
            //some logic
            return pendingRequestService.processRequestSubscribeOn(request);
        });
    }
}


public class PendingRequestService {
    ...
    private RequestSubscribeResult processRequestSubscribe(String san, long serviceSpecIId, String superUid,
                                                           boolean isRequestSubscribe, Long priceListId, boolean isAdminUiNotify) {
        return ctx.getSession().doInTransaction(() -> {
           //susbcribe logic
        });
    }

    public RequestSubscribeResult processRequestSubscribeOn(SubscribeOnRequest request) {
        return ctx.getSession().doInTransaction(() ->
                processRequestSubscribe(request.getServiceAccountNumber(), request.getServiceSpecIId(),
                        request.getSuperUid(), true, request.getPriceListId(), request.isAdminUiNotify()));
    }
    ...
}
```
</details>

<details>
<summary>После</summary>

```java

public class RequestSubscribeFacade {
    ...

    public RequestSubscribeResult subscribeOn(SubscribeOnRequest request) {
        final Session session = ctx.getSession();

        return session.doInTransaction(() -> {
            //some logic
            return pendingRequestService.processRequestSubscribe(request.getServiceAccountNumber(), request.getServiceSpecIId(),
                    request.getSuperUid(), true, request.getPriceListId(), request.isAdminUiNotify());
        });
    }
}


public class PendingRequestService {
    ...
    public RequestSubscribeResult processRequestSubscribe(String san, long serviceSpecIId, String superUid,
                                                           boolean isRequestSubscribe, Long priceListId, boolean isAdminUiNotify) {
        return ctx.getSession().doInTransaction(() -> {
           //susbcribe logic
        });
    }
    ...
}
```
</details>

Есть логика подписки услуги. Всё начинается с команды(это такой класс), команда вызывает метод в фасаде, фасад делает вызов метода из сервиса, в сервисе этот метод вызывает другой метод. 
В каждом из методов данные обрабатываются тем или иным образом. Но есть метод в цепочке от которого можно безболезненно избавиться: processRequestSubscribeOn.
Логика и так дальше оборачивается в транзакцию, единственное, что в фасаде нужно передавать не один параметр при вызове метода, а несколько. 
Итог: минус один метод в цепочке вызовов.

#### 3. У метода слишком большой список параметров
<details>
<summary>До</summary>

```java
    private void renameNodeAndGetFieldTranslation(List<Node> nodeList, String fieldName, String idNodeName, String nodeName,
                                                  String expectedNodeName, ExecutionContext ctx) throws Exception {
        // for each channel (nodes) from the list, change bcdesc to bcdesc_loc with the translation added
        for (Node mainNode : nodeList) {

            // get the node bcdesc from the channel
            Node neededNode = mainNode.getRealChild(nodeName);

            // get id for further transfer
            Node idNode = mainNode.getRealChild(idNodeName);

            // if bcdesc is not found, just skip checking for the current channel
            if (neededNode == null) {
                continue;
            }

            // get the value of the node bcdesc
            Node neededValueNode = neededNode.getRealChildAt(0);

            // get id value
            Node idValueNode = idNode.getRealChildAt(0);

            // if suddenly a node with the value bcdesc was found, skip
            if (neededValueNode == null) {
                continue;
            }

            // get the string value of the node bcdesc and id
            String neededValue = neededValueNode.toString();
            String idValue = idValueNode.toString();

            // get the translation using id and the name of the field,
            // search goes to SERVICE_SPEC, not CONTENT!
            List<List<String>> listResult = ctx.getSession().executeQuery(
                    LoadLocalizationDataProcessor.getTranslationSqlForExecuteQuery("SERVICE_SPEC"),
                    Binder.bind("ENTITY_ID", idValue),
                    Binder.bind("FIELD_NAME", fieldName));
            CommandResult commandResult = new CommandResult(listResult);

            // remove bcdesc from the main node to replace it with bcdesc_loc
            mainNode.deleteChild(nodeName);

            // create a node bcdesc_loc
            Node nodeLoc = new Node(expectedNodeName, Node.NodeType.ELEMENT);
        ...
        }
```
</details>

<details>
<summary>После</summary>

```java
    private void renameNodeAndGetFieldTranslation(List<Node> nodeList, ExecutionContext ctx) throws Exception {
        // for each channel (nodes) from the list, change bcdesc to bcdesc_loc with the translation added
        for (Node mainNode : nodeList) {

            // get the node bcdesc from the channel
            Node neededNode = mainNode.getRealChild("bcdesc");

            // get id for further transfer
            Node idNode = mainNode.getRealChild("bc_r_id");

            // if bcdesc is not found, just skip checking for the current channel
            if (neededNode == null) {
                continue;
            }

            // get the value of the node bcdesc
            Node neededValueNode = neededNode.getRealChildAt(0);

            // get id value
            Node idValueNode = idNode.getRealChildAt(0);

            // if suddenly a node with the value bcdesc was found, skip
            if (neededValueNode == null) {
                continue;
            }

            // get the string value of the node bcdesc and id
            String neededValue = neededValueNode.toString();
            String idValue = idValueNode.toString();

            // get the translation using id and the name of the field,
            // search goes to SERVICE_SPEC, not CONTENT!
            List<List<String>> listResult = ctx.getSession().executeQuery(
                    LoadLocalizationDataProcessor.getTranslationSqlForExecuteQuery("SERVICE_SPEC"),
                    Binder.bind("ENTITY_ID", idValue),
                    Binder.bind("FIELD_NAME", "description"));
            CommandResult commandResult = new CommandResult(listResult);

            // remove bcdesc from the main node to replace it with bcdesc_loc
            mainNode.deleteChild("bcdesc");

            // create a node bcdesc_loc
            Node nodeLoc = new Node("bcdesc_loc", Node.NodeType.ELEMENT);
    ...
    }
```
</details>

Обнаружил метод с 6-ю параметрами, который используется лишь в одном месте. При этом 4 параметра строковые литералы, которые не изменяются.
Убрал лишние параметры в методе, заменив обращение к переменным внутри метода на использование литералов. Теперь в методе не 6 параметров, а 2. 
Дополнительно можно было бы сделать эти литералы константами.


#### 4. Странные решения
<details>
<summary>Код</summary>

```java
public class StringHelper {

    public static boolean isEmpty(String value, boolean trim) {
        return value == null || (trim ? value.trim().length() < 1 : value.length() < 1);
    }

    public static boolean isEmpty(String value) {
        return isEmpty(value, true);
    }

    private StringHelper() {
    }
}

...

public class someClass {

    public void someMethod() {
        StringUtils.isBlank(header);
        StringHelper.isEmpty(header);
    }
}
    
```
</details>

Обнаружил в коде класс StringHelper с методами проверки строки на пустоту. В некоторых местах вызывается его метод isEmpty(String value), который проверяет что строка null или пустая/содержит одни пробелы.  
Также у нас используется библиотека Apache Commons Lang. В ней есть класс StringUtils, содержащий аналогичный метод для проверки строки, который называется isBlank.
В некоторых местах кода для проверки строки на пустоту используется метод StringUtils.isBlank(String value), а в некоторых -- StringHelper.isEmpty(String value). При этом делают они одно и то же.
Решение: удалить StringHelper и вызовы его методов заменить на обращения к StringUtils.

#### 5. Чрезмерный результат
<details>
<summary>До</summary>

```java
@Component
@RequiredArgsConstructor
public class ToClientAddCommandParamConverter implements Converter<Map<String, String>, ClientAddCommandParams> {
    private final ExecutionContext ctx;
    private final ClientService clientService;
    private final ServiceProviderDao serviceProviderDao;
    private final DictionaryDao dictionaryDao;

    @SneakyThrows
    @Override
    public ClientAddCommandParams convert(Map<String, String> params) {
        
        ...
        
        ServiceProviderDto serviceProviderDto = serviceProviderDao.findByExternalId(serviceProviderExternalId)
                .orElseThrow(() -> new CommandException("Service provider doesn't found by external id"));
        
        ...

        return ClientAddCommandParams.builder()
                ...
                .serviceProviderId(serviceProviderDto.getId())
                ...
                .build();
    }
...
```
</details>

<details>
<summary>После</summary>

```java
@Component
@RequiredArgsConstructor
public class ToClientAddCommandParamConverter implements Converter<Map<String, String>, ClientAddCommandParams> {
    private final ExecutionContext ctx;
    private final ClientService clientService;
    private final ServiceProviderDao serviceProviderDao;
    private final DictionaryDao dictionaryDao;

    @SneakyThrows
    @Override
    public ClientAddCommandParams convert(Map<String, String> params) {
        
        ...

        Long serviceProviderId = serviceProviderDao.findIdByExternalId(serviceProviderExternalId)
                .orElseThrow(() -> new CommandException("Service provider doesn't found by external id"));
        
        ...

        return ClientAddCommandParams.builder()
                ...
                .serviceProviderId(serviceProviderId)
                ...
                .build();
    }
...
```
</details>

В одном из конвертеров нам нужен идентификатор провайдера. Для его получения выполняется запрос в БД, однако данные возвращаются в виде дто, в котором 16 полей,
тогда как нам нужно всего одно -- id. Заменил метод, который мы используем для обращения к БД. Теперь возвращается не дто, а только нужный нам идентификатор.