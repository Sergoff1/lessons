Предусловия и постусловия в общих методах в целом совпадают.  
В постусловии для метода `remove()` я написал больше конкретики: указал как должен вести себя массив после удаления элемента(сдвиг элементов).
Мне показалось важным отметить, что в этой структуре данных не должно быть "дырок" в массиве. 
Возможно это было лишним и получившийся уровень абстракции моего АТД несколько ниже чем у эталонного. 
Ибо, кажется, что можно сделать реализацию динамического массива, которая будет нормально работать с "дырками", она будет сложнее, но требованиям эталонной АТД удовлетворит.   

Думаю, что мой АТД может иметь право на жизнь, может у нас такая ситуация, когда важно, чтобы все реализации АТД были без "дырок". И тогда моё описание выглядит приемлемым.

Думал какие методы добавить для удобства и как бы не переборщить. Решил остановиться на `clear` и `append`. 
Основной метод для вставки элемента у меня `insert(int index, T value)`. В его постусловии я тоже написал про сдвиг элементов.

В эталоне используется `put`. У себя думал завести похожий метод `replace`, но решил отказаться от этой затеи, так как эту задачу могут решить имеющиеся `remove` и `insert`. 
Хотя в рамках моего АТД метод `replace` был бы кстати, так как ему не нужны сдвиги и его реализация была бы гораздо эффективнее. Это напомнило мне про операцию `tail` в `LinkedList` (можно и без неё, но эффективность реализаций упадёт).

Эталонные методы `put_left` и `put_right` можно выразить с помощью моего `insert`.
